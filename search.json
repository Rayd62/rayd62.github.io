[{"title":"协议栈 - 套接字断开","url":"/2022/01/14/10.%E5%8D%8F%E8%AE%AE%E6%A0%88-%E5%A5%97%E6%8E%A5%E5%AD%97%E6%96%AD%E5%BC%80/","content":"前言这个系列的博客是针对阅读《网络是怎样连接的》（[日] 户根勤, 译 [中] 周自恒, ISBN: 9787115441249）一书的记录与思路整理。有些概念是做纯路由交换的网络工程师很少接触但又很重要的部分，因此整理到这里以做分享。\n\n\n协议栈 - 套接字断开TCP 连接断开顺序 - 四次挥手\n无论是服务器或者是客户端在发送&#x2F;接收完数据后都有可能主动发起连接关闭的请求（具体由谁发起，是根据更上层协议决定的；例如在HTTP 1.0 中，服务器在数据传输完成后主动发起连接关闭；而在HTTP 1.1 中，服务器在传输完数据后，客户端仍然可以继续请求，关闭连接的请求只能由客户端主动发起的）。连接关闭请求的本质是在TCP 包头中将控制位的FIN 比特设置为1。\n以服务器优先发起断开连接为例\n\n服务器一方的应用程序在完成数据传输后，调用Socket 库的close 程序。\n服务器协议栈生成包含断开信息的TCP 头部，即将TCP头部的控制位的FIN 设置为1\n协议栈委托IP模块向客户端发送数据。同时，服务器的套接字中会记录下断开操作的相关信息。\n客户端收到服务器发来的控制位FIN为1 的TCP 数据包，这时客户端的协议栈会将自己的套接字标记为进入断开操作状态。\n为了告知服务器，客户端已经收到FIN 包，客户端会向服务器返回一个ACK（控制位ACK 为1 )\n这个操作完成后，协议栈就可以等待应用程序来取数据了。\n应用程序会调用read 来读取数据。这时，协议栈不会向应用程序传递数据，而是告知应用程序来自服务器的数据已全部收到。\n客户端应用程序收到消息后也调用close 来结束数据收发操作，这时客户端的协议栈也会和服务器一样，生成一个FIN 为1的数据包，然后委托IP 模块发送给服务器。\n服务器收到客户端的FIN包后，返回一个ACK 报文，告知客户端已收到。至此，客户端和服务器的通信就全部结束了。\n\n\n套接字的删除和服务器的通信结束后，用来通信的套接字也就不会再使用了，这时系统可以删除套接字了。不过，套接字并不会立即被删除，而是会等待一段时间之后再被删除。\n等待的这段时间是为了防止误操作，引发误操作的原因有很多。举一个例子为例。\n假设，本次连接是客户端首先发起断开请求，那么断开顺序如下：\n\n客户端发送FIN 包\n服务器返回ACK\n服务器发送FIN包\n客户端返回ACK\n\n此时，如果最后的客户端返回的ACK号丢失，那么在一定时间后客户端就必须重发一个FIN。那么这个时候套接字如果已经删除，且原套接字中的端口号（or 描述符？）已经分配给另一个套接字了。此时收到的FIN包会被分配给新的套接字，而新的套接字收到FIN包后就开始执行断开操作了。这就是为什么不马上删除套接字，就是为了防止类似的误操作。\n","tags":["读书笔记","网络技术","网络是怎样连接的"]},{"title":"包的基本知识","url":"/2022/01/17/11.%E5%8C%85%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/","content":"前言这个系列的博客是针对阅读《网络是怎样连接的》（[日] 户根勤, 译 [中] 周自恒, ISBN: 9787115441249）一书的记录与思路整理。有些概念是做纯路由交换的网络工程师很少接触但又很重要的部分，因此整理到这里以做分享。\n\n\n包的基本知识在前期一系列的讲解中我们谈到了应用程序（浏览器）如何调用操作系统协议栈来使用TCP 协议与远程服务器去建立连接、传输数据和关闭连接的过程。其中我们多次说到了TCP包头、IP包头的概念。\n那么什么是包呢？\n这是一个抽象的概念，它概括了数据在网络中传输的一种形态。逻辑上，我们认为包是由头部和数据两部分构成。\n头部包含了控制信息，例如IP 头部包含了源目IP 地址；TCP 头部包含了序列号，ACK 号，SYN、ACK、FIN 等控制位。可以将其理解为快递包裹的面单（指明了谁是发件人，是收件人，是航空件还是陆运件，是加急件还是普通件）。\n数据就是头部后面委托方要发送给对方的数据，也就相当于快递包裹内部的货物。\n\n如上图，对于TCP 来说，上层应用数据委托的数据块就是TCP 的数据；对于IP 头部来说，整个TCP 包就是其数据。\n包的转发发送方负责将包创建好，添加各类控制信息，然后附加上需要发送的数据。接下来，包就会被发往最近的网络转发设备。当数据包到达最近的转发设备之后，转发设备会根据头部中的信息判断接下来应该发往哪里。这个过程需要用到一张表，这张表里面记录了每一个地址对应的发送方向，也就是按照头部里面记录的目的地址在表中进行查询，并根据查到的信息判断接下来应该发往哪个方向。例如，表内查询结果是“目标地址为xxx 的包应该发到xxx号线路”，那么转发设备就会把这个包发送到xxx号线路去。数据包就这样一路被转发，直至到达目的地。\n\n还是以快递类比，例如，A从深圳发送一个包裹到北京的B。那么A首先要填写一个快递单（控制信息），然后将要发送的货物打包成箱（数据），然后将快递单号贴在货物箱上（封装）。之后，A 将包裹交给快递员，快递员将包裹送往最近的快递集散中心（数据包发送给最近的转发设备）。快递集散中心收到包裹后，查看快递单信息，发现是发送到北京的包裹，他们将包裹放到发往广州集散中心的货车上，将包裹送往广州（路由选择）。当广州的集散中心收到包裹查看快递单，发现是发往北京的包裹，他们将包裹发往白云机场，送上直飞北京的货运飞机。到达北京后，北京机场的快递集散中心，将包裹又放上送往西城区集散中心的货车。最终，西城区的快递员收到包裹，成功将包裹交到B 手中，整个送货过程（转发过程）结束。\n\n整个转发需要涉及到两种不同的地址IP地址（逻辑地址）和MAC 地址（物理地址）。\n\nIP地址根据目标地址判断下一个IP转发设备的位置；\nMAC 地址根据以太网协议将数据包传输到下一个转发设备。\n\n发送方将数据包发往目的地时，在控制信息（IP包头）中写入要访问的服务器IP地址（类似快递面单的目的地址）。这样一来，所有沿途的转发设备都知道数据包的最终目的地址是什么了，IP协议可以根据这一地址查找数据包的传输方向，从而找到下一个路由器的位置。接下来，IP协议会委托以太网协议将数据包传送到下一个路由器。这时，IP 协议会查找下一个路由器的以太网地址（MAC 地址），并将该地址写入MAC 头部。这样一来，以太网协议就知道要将这个包发送到哪一个路由器上了（个人愚见，为何需要两个地址。一个是因为协议分层，IP 在逻辑上指明源目地址即可，物理上如何实现转发需要另一个协议层来执行，所以有两个地址；另外，以太网默认情况下是一个点到多点的网络，即使两台路由器是直联状态，也需要MAC 地址在多点中去明确下一跳到底是哪里）。\n\n分层浅识在整个转发过程中，IP 和以太网是有明确分工的。也就是IP协议层和以太网协议层是分开的。在这里，以太网实际上是可以替换成其它协议的，例如：无线局域网（Wi-Fi），ADSL（调制上网技术），FTTH（光纤入户）等等，这些协议都可以替代以太网来协助IP协议传输数据包。\n\n同样的，传输层有TCP和UDP 协议，它们都可以委托IP 协议来传输数据包。分层的特性让不同协议来使用IP 协议进行传输成为可能。\n\n因此，将IP和负责实际传输的网络分开，可以更好地根据需要使用各种通信技术。互联网这样庞大复杂的网络，从架构上需要保证灵活性，这就是设计这种分工&#x2F;分层方式的原因。\n但是需要注意的是，在操作系统中，IP 模块（非协议）负责给数据包添加MAC 头部和IP头部。\n","tags":["读书笔记","网络技术","网络是怎样连接的"]},{"title":"使用Docker 搭建Ghost","url":"/2022/01/04/1.%E4%BD%BF%E7%94%A8Docker-%E6%90%AD%E5%BB%BAGhost/","content":"前言最近在阿里云上买了一台轻量服务器，初衷是用来做爬虫的，但是试了几天拿到的数据效果不太理想，资源闲置也是浪费干脆搭一个自己的Blog 来做记录和分享。\n这篇文档就这么诞生了，主要是记录一下折腾Ghost 博客系统的过程。\n\n安装Docker本文使用的环境是CentOS 8.2（个人习惯使用RHEL 的系统，和Ghost 官方推荐的Ubuntu 在安装程序和创建用户的部分有一点点不一样而已。）\n推荐使用一个用户账号进行下列操作，但是涉及到很多权限的修改。如果对Linux 不熟悉可以直接使用root 账号完成下列操作。\n安装依赖sudo yum install -y yum-utils\n\n\n配置阿里云的镜像仓库yum-config-manager \\    --add-repo \\    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n\n更新yum 源yum makecache\n\n\n安装Docker 程序# 清理现有环境Docker，官方镜像无需进行sudo yum remove docker \\                  docker-client \\                  docker-client-latest \\                  docker-common \\                  docker-latest \\                  docker-latest-logrotate \\                  docker-logrotate \\                  docker-engine# 安装Docker yum install docker -y# 安装前会有如下告警，输入y 并回车# 可以到https://docs.docker.com/engine/install/centos/ 的install Docker Engine 的那一步检查指纹警告：/var/cache/dnf/docker-ce-stable-ab4061364e2cf0db/packages/containerd.io-1.4.9-3.1.el8.x86_64.rpm: 头V4 RSA/SHA512 Signature, 密钥 ID 621e9f35: NOKEYDocker CE Stable - x86_64                                                                                                      21 kB/s | 1.6 kB     00:00导入 GPG 公钥 0x621E9F35: Userid: &quot;Docker Release (CE rpm) &lt;docker@docker.com&gt;&quot; 指纹: 060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35 来自: https://mirrors.aliyun.com/docker-ce/linux/centos/gpg确定吗？[y/N]： y\n\n\n启动Docker# 启动docker 进程systemctl start docker# 检查docker 进程状态，状态如下为Active 就是正常的systemctl status docker● docker.service - Docker Application Container Engine   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)   Active: active (running) since Fri 2021-09-24 20:46:19 CST; 51s ago# 将docker 进程加入开机启动systemctl enable docker\n\n\n配置阿里云Docker镜像加速在阿里云控制台找到容器镜像服务，选择最下面的镜像加速器，获取加速器地址。注意每个用户的加速器地址不一致，需要自行去该页面获取。\n\n在服务器上，复制上图中右下角红框中的代码，执行。完成后使用systemctl daemon-reload和systemctl restart docker 重启docker 服务。\n使用Docker-Compose 启动Ghost安装Docker-Compose可根据官方文档进行安装：https://docs.docker.com/compose/install/#alternative-install-options\n# 下载docker-compose sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose# 修改docker-compose 权限chmod +x /usr/local/bin/docker-compose# 创建软链ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose# 测试docker-compose -v# 输出docker-compose version 1.29.2, build 5becea4c\n\n\n环境准备建立永久的Ghost 和Mariadb 数据存储目录# 创建docker-compose.yml 中两个映射Volume 的目录# 记住修改mkdir /home/ray/ghost_data /home/ray/mariadb_data\n\n\n创建独立的Docker 网络# 可选项，如果不需要，则将下面docker-compose.yml 中关于网络设置的部分删除docker network create ghost-network\n\n\n使用compose 启动docker在用户根目录创建文件docker-compose.yml\nvim ~/docker-compose.yml# 将下面的内容粘贴到该文件，并保存version: &#x27;2&#x27;services:# 使用mariadb 作为后台的数据库  mariadb:    image: mariadb:10.6.4    volumes:    # 使用/home/ray/mariadb_data 作数据库存储，需要与上一步骤建立的目录保持一致      - &#x27;/home/ray/mariadb_data:/var/lib/mysql&#x27;    environment:      # ALLOW_EMPTY_PASSWORD is recommended only for development.      - ALLOW_EMPTY_PASSWORD=no      # 下列账号密码根据使用情况自行更改      - MARIADB_ROOT_PASSWORD=xxxxxx      # 若Ghost 使用ROOT 账号可以删除下面的USER和PASSWORD      - MARIADB_USER=xxxxxx      - MARIADB_PASSWORD=xxxxxx      - MARIADB_DATABASE=ghost_database      - MARIADB_MASTER_HOST=mariadb    # 上一步骤若不进行network 配置则删除该部分    networks:      - ghost-network  ghost:    image: ghost:4.15.0    # Ghost 镜像通过外部的3301 端口连接    ports:      - &#x27;3301:2368&#x27;    volumes:    # 使用/home/ray/ghost_data 存储Ghost 数据，需要与上一步骤建立的目录保持一致      - &#x27;/home/ray/ghost_data:/var/lib/ghost/content&#x27;    depends_on:      - mariadb    environment:      # ALLOW_EMPTY_PASSWORD is recommended only for development.      - url=http://47.107.106.229:3301 # 注意这里改成自己的公网IP，否则启动博客后页面跳转有问题      - ALLOW_EMPTY_PASSWORD=no      - GHOST_DATABASE_HOST=mariadb      - GHOST_DATABASE_PORT_NUMBER=3306      - GHOST_DATABASE_NAME=ghost_database      # 数据库账户和密码与Mariadb 中设置保持一致      - GHOST_DATABASE_USER=root      - GHOST_DATABASE_PASSWORD=xxxxxx      - mail__transport=SMTP      # 我使用的是qq 邮箱作为SMTP 服务      - mail__options__host=stmp.qq.com      - mail__options__port=587      # 使用自己的邮箱      - mail__options__auth__user=xxxxx@qq.com      # 使用邮箱SMTP 的授权码，去邮箱的“设置”-“账号”页面申请，使用QQ密码是不行的      - mail__options__auth__pass=xxxxxxxxxxxxxx      # 发件人，可以与auth_user 一致      - mail__from=xxxxx@qq.com    # 上一步骤若不进行network 配置则删除该部分    networks:      - ghost-network# 上一步骤若不进行network 配置则删除该部分networks:    ghost-network:        external: true\n\n\n使用docker-compose up拉起服务，第一次拉起会比较慢，因为需要从docker hub 先下载配置中用到的mariadb 和ghost 的docker 镜像。\n配置阿里云防火墙在阿里云的控制台，添加规则放通TCP 3301 端口。\n\n大功告成然后通过浏览器访问http://47.107.106.229:3301 即可访问博客的主页。\n通过http://47.107.106.229:3301/ghost 访问Ghost 控制台。\n关于第一次使用注册账号的问题我测试过将docker 0 的网络配置中的ipv4.dns设置为外网的DNS 尝试去解析smtp.qq.com尝试了几次都显示失败了。显示无法认证不确定是smtp 账号认证的问题还是dns 的问题。\n不过在发送邮件之后遇到报错，直接刷新页面，然后使用刚刚填写的账号密码也可以直接进入ghost 的管理页面。\n\n最后在GitHub上找到一个case ，大意是说docker-compose 的方式需要额外加入network_mode: network_mode: bridge 可以解决问题。但因为博客更换为Hexo 搭建，并没有做进一步尝试。\n\n","tags":["建站","公有云"]},{"title":"将IP 包发送出去","url":"/2022/01/19/12.%E5%B0%86IP-%E5%8C%85%E5%8F%91%E9%80%81%E5%87%BA%E5%8E%BB/","content":"前言这个系列的博客是针对阅读《网络是怎样连接的》（[日] 户根勤, 译 [中] 周自恒, ISBN: 9787115441249）一书的记录与思路整理。有些概念是做纯路由交换的网络工程师很少接触但又很重要的部分，因此整理到这里以做分享。\n\n\n将IP 包发送出去IP 生成的网络包只是存放在计算机内存中的一串数字信息，没有办法直接发送给接收方。因此，需要将数字信号转换成电或光信号，才能在网线或光纤上传输。\n负责这一操作的是网卡，在操作系统中需要配置网卡需要的网卡驱动程序，操作系统才能够正确地调度网卡的硬件资源来完成电或光信号的转换。\n\n硬件设备初始化网卡和其它硬件一样，并非通电后就可以直接工作的。在设备开机之后，网卡驱动程序会对硬件进行初始化操作，然后硬件才进入可以使用的状态。\n操作包括了：\n\n硬件错误检查（通用硬件操作）\n初始设置（通用硬件操作）\n在控制以太网收发操作的MAC （Media Access Control）模块中设置MAC 地址（网卡独有）\n\n网卡的ROM 中保存着全世界唯一的MAC 地址，这是在生产网卡时写入的，将这个值读取并写入MAC 模块的设置中，MAC 模块就知道自己对应的MAC 地址了。当然也可以通过一些特殊的方法，比如从命令或者配置文件中读取MAC 地址并分配给MAC 模块。这种情况下，网卡会忽略ROM中的MAC地址。\n\n“有人认为在网卡通电之后，ROM 中的 MAC 地址就自动生效了，其实不然，真正生效的是网卡驱动进行初始化时在 MAC 模块中设置的那个 MAC 地址 。在操作系统启动并完成这些初始化操作之后，网卡就可以等待来自 IP 的委托了。”摘录来自: ［日］ 户根勤. “网络是怎样连接的。” \n\n给网络包再加3个控制数据哪3个控制数据\n报头（帧头）\n由7个“1010”电信号构成的序列，一共7bytes\n\n\nSFD（起始帧分界符）\n由“1011”电信号构成，1bytes。告诉接收方这是数据开始的地方。\n\n\nFCS（帧校验序列）\n用来检查包传输过程中因噪音等因素导致的波形紊乱、数据错误，4bytes 的序列。通过循环冗余校验计算得出\n\n\n\n数字信号转换成电信号需要让“0”和“1”两种比特分别对应特定的电压和电流即可，这样电信号就可以表达数字信号了。\n将电信号转换成数字信号通过电信号读取数据的过程就是将电压和电流重新转换成“0”和“1”的过程。我们可以通过测量电压和电流来判断，电信号表达的是数字信号中的“1”还是“0”。如下图：\n\n但这样会存在一个问题：如果出现连续的“1”或者“0”的信号时，电压和电流会在一段时间保持一致，我们该如何确定这一段持续的时间内的电压和电流表示了多少个连续的“1”或者“0”呢？\n因此，我们必须判断出每个比特在电流中的界限在哪里，就像上图中每个比特之间都用一个虚线作出了间隔，这样就能解决遇到连续的“0”和“1”的问题了。那么在实际的工程应用中，这个虚线肯定是不存在的，最简单的方法是在数据信号之外再发送一组用来区比特间隔的信号，即“时钟信号”。那么，在接收方读取电信号的时候，就可以规定当“时钟信号”从下往上时（也可以规定当 “时钟信号” 从上往下时），读取“数据信号”的电压和电流值，并转换成一个比特的数字信号。如下图：\n在这里有另一个问题需要考虑，当线路过长时，两条线路的长度对于光速（无论是光纤还是电缆）都是有差异的，也就是数据传输和时钟传输会有时间差。这样“时钟信号”和“数据信号”就无法对应了。\n解决这个问题的办法是，将“数据信号”和“时钟信号”叠加到一起，合并为一个电流（或光）进行传输。由于“时钟信号”是按固定频率进行变化的，只要能够找到“时钟信号”的变化周期就能从叠加信号中提取“时钟信号”，进而计算出“数据信号”。\n所以，我们不能直接就发送包的数据，而是要在前面加上一段用来测量时钟信号的特殊信号，这就是报头的作用。即下图：\n\n\n“如果在包信号结束之后，继续传输时钟信号，就可以保持时钟同步的状态，下一个包就无需重新进行同步。有些通信方式采用了这样的设计，但以太网的包结束之后时钟信号也跟着结束了，没有通过这种方式来保持时钟同步，因此需要在每个包的前面加上报头，用来进行时钟同步。”摘录来自: ［日］ 户根勤. “网络是怎样连接的。”\n\n以太网根据速率和网线类型的不同分为多种派生方式，每种方式的信号形态也有差异，并不都是像本例中讲的这样，单纯通过电压和电流来表达 0 和 1 的。因此，101010…这样的报头数字信息在转换成电信号后，其波形也不一定都是图 2.25 中的那个样子，而是根据方式的不同而不同。但是，报头的作用和基本思路是一致的。\n将数据包发送出去加上报头、起始帧分界符和FCS 之后，我们就可以将包通过网线发送出去了。（在这里我们只讨论全双工模式，所以不讨论半双工下如何避免信号碰撞）\n首先，MAC 模块从报头开始将数字信息按每比特转换成电信号，然后由PHY（在100Mbit&#x2F;s 以上的以太网中都叫PHY， Physical Layer Device；其它时候，有些地方也叫MAU，Medium Attachment Unit）信号收发模块发送出去。在这里，将数字信号转化为电信号的速率就是网络的传输速率、例如每秒将10Mbit 的数字信息转换成电信号发送出去，则速率就是10Mbit&#x2F;s。\nPHY模块会将信号转换为可在网线上传输的格式，并通过网线发送出去。以太网对不同网线类型、速率以及其它对应的信号格式进行了规定，但MAC模块并不关心这些区别，而是将可转换为任意格式的通用信号发送到PHY模块，然后由PHY模块再将其转换为可传输格式。\n接收返回包信号的开头是报头，通过报头的波形同步时钟，然后遇到起始帧分界符时开始将后面的信号转换成数字信息。\n这时与发送时是相反的，即PHY模块会将信号转换成通用格式并发送给MAC 模块，MAC模块再从头开始将信号转换为数字信号，并放入缓冲区中。当到达信号的末尾时，还需要检查FCS。如果FCS 检测失败，则判断这个包为错误包，网卡将其丢弃。\n如果FCS 检验无误，接下来就要看一下MAC头部中的接收方MAC地址与网卡在初始化时分配给自己的MAC地址是否一致，以判断这个包是不是发送给自己的。如果不是，则直接将包丢弃；如果是，则将包放入缓冲区中。到这里MAC模块在接收数据包时的工作就完成了，接下来网卡会通知系统收到了一个包。\n\n“有一个特殊的例子，其实我们也可以让网卡不检查包的接收方地址，不管是不是自己的包都统统接收下来，这种模式叫作“混杂模式”（Promiscuous Mode）。”摘录来自: ［日］ 户根勤. “网络是怎样连接的。”\n\n通知计算机通知计算机操作系统的操作会使用到中断机制。\n为什么这里会有中断？\n在网卡接收数据包的操作中，操作系统不会一直监控网卡的活动，而是去执行其它任务。因此，如果网卡一直不通知操作系统，操作系统是无法得知网卡收到了数据包。网卡驱动也是操作系统中运行的一个程序，因此它也不知道包到达了。这种情况下，我们需要一种机制能够打断操作系统正在执行的任务，让它注意到网卡中发生的事情，这种机制就是中断。\n中断的工作过程是这样的：\n\n网卡向扩展总线中的中断信号线发送信号，该信号线通过计算机中的中断控制器连接到CPU；\n当产生中断信号时，CPU会暂时挂起正在处理的任务，切换到操作系统中的中断处理程序；\n中断处理程序会调用网卡驱动，控制网卡执行相应的接收操作；\n网卡驱动被中断处理程序调用后，会从网卡的缓冲区取出收到的包，并通过MAC头部中的以太网类型字段判断协议的类型；\n协议类型如果是0x0800代表IP协议（除了TCP&#x2F;IP协议外，还有很多其它的协议，不过现在的主流是TCP&#x2F;IP协议了），网卡驱动就会把这样的包交给TCP&#x2F;IP协议栈。接下来，协议栈会判断这个包应该交给哪个应用程序，并进行相应的处理。\n\n\n“中断是有编号的，网卡在安装的时候就在硬件中设置了中断号，在中断处理程序中则将硬件的中断号和相应的驱动程序绑定。例如，假设网卡的中断号为 11，则在中断处理程序中将中断号 11 和相应的网卡驱动绑定起来，当网卡发起中断时，就会自动调用网卡驱动了。现在的硬件设备都遵循即插即用 98 规范自动设置中断号，我们没必要去关心中断号了，在以前需要手动设置中断号的年代，经常发生因为设置了错误的中断号而导致网卡无法正常工作的问题。”摘录来自: ［日］ 户根勤. “网络是怎样连接的。”\n\n将包交给上层协议栈处理假设服务器返回的数据包是以太网类型0x0800，网卡会将数据包交给TCP&#x2F;IP协议栈来进行处理。\n接下来就轮到IP模块先开始工作了。第一步检查IP头部，确认格式是否正确。如果格式正确，下一步就是查看接收方IP地址，返回的数据包的目的地址一定与设备的网卡地址一致，检查确认之后我们就可以接收这个包了。\n如果接收方IP地址与IP包头的目的地址不一致，那么肯定是发生了错误（客户端不负责对包进行转发，因此不应该收到不是发给自己的包）。当发生这样的错误时，IP模块会通过ICMP消息将错误告知发送方。\n如果接收方IP地址与IP包头的目的地址一致，则这个包会被正常接收。此时，IP模块会检查收到的包是否为IP分片（IP分片再另外章节讨论），如果是IP分片，则IP模块会将其暂存至内部的内存空间，等待IP头部中具有相同标识的包全部到达，并根据分片偏移量字段，将所有分片（数据包）还原成原始的包，这个操作叫做分片重组。\n到达这一步IP模块的工作就结束了，接下来包会被交给TCP模块。TCP模块根据IP包头中的源目IP地址，和TCP头部中的源目端口号来查找对应的套接字。找到对应的套接字之后，就可以根据套接字中记录的通信状态，执行相应的操作了。例如：如果包的内容是应用程序数据，则返回确认接收报文，并将数据放入缓冲区，等待应用程序接收；如果是建立或断开连接的控制包，则返回相应的相应控制包，并告知应用程序建立或断开连接的操作状态。\n\n“严格来说，TCP 模块和 IP 模块有各自的责任范围，TCP 头部属于 TCP 的责任范围，而 IP 头部属于 IP 模块的责任范围。根据这样的逻辑，当包交给 TCP 模块之后，TCP 模块需要查询 IP 头部中的接收方和发送方 IP 地址来查找相应的套接字，这个过程就显得有点奇怪。因为 IP 头部是 IP 模块负责的，TCP 模块去查询它等于是越权了。如果要避免越权，应该对两者进行明确的划分，IP 模块只向 TCP 模块传递 TCP 头部以及它后面的数据，而对于 IP 头部中的重要信息，即接收方和发送方的 IP 地址，则由 IP 模块以附加参数的形式告知 TCP 模块。然而，如果根据这种严格的划分来开发程序的话，IP 模块和 TCP 模块之间的交互过程必然会产生成本，而且 IP 模块和 TCP 模块进行类似交互的场景其实非常多，总体的交互成本就会很高，程序的运行效率就会下降。因此，就像之前提过的一样，不妨将责任范围划分得宽松一些，将 TCP 和 IP 作为一个整体来看待，这样可以带来更大的灵活性。”摘录来自: ［日］ 户根勤. “网络是怎样连接的。”  \n\n","tags":["读书笔记","网络技术","网络是怎样连接的"]},{"title":"信号在网线中传输","url":"/2022/02/11/13.%E4%BF%A1%E5%8F%B7%E5%9C%A8%E7%BD%91%E7%BA%BF%E4%B8%AD%E4%BC%A0%E8%BE%93/","content":"每个包都是独立传输的 两个终端间的数据传输，依赖于两个设备间的集线器、交换机、路由器等转发设备将终端发出的包转发，最终抵达对端。\n这个过程中，交换机、路由器等转发设备使用数据包的控制信息（可以是MAC，也可以是IP），在设备内部的一个记录转发规则的表中查询，从而判断数据包的去向（下一跳）。\n所以转发设备只关心数据包的头部控制信息而不关心数据包的数据内容。\n这可以与快递员进行类比，快递员在派送快递时只关心快递的面单，而不关心包裹内装的是什么。\n\n\n防止网线中的信号衰减此处只探讨电信号的问题，光纤的光信号衰减是另一个话题。\n为什么会产生信号衰减（失真）\n信号在网线的传输过程中，能量会逐渐损失。网线越长，信号衰减越严重\n电信号的频率越高（频率高，意味着速度快），能量的损失也越大（高频信号会释放更多的电磁波，这些电磁波带走了一部分能量，也造成了能量的损失）\n线路噪音：网线周围的电磁波，当电磁波接触到金属等导体时，其中就会产生电流。因此，双绞线周围存在电磁波就会对网线中原有的信号产生干扰\n\n衰减对数据的传输有什么影响信号在传输过程中不断衰减，波形就会失真，导致接收方难以辨别信号的实际意义。（在双绞线中电信号实际就是高低电压的变换，当电压的高低变换产生失真，接收方将无法准确判断电压的高低变换情况，也就无法在目的地将电信号转化成发送方希望发送的数字信号了）\n\n如何解决电信号衰减的问题产生信号衰减的原因1、2 并没有很好的办法，只能在实际的项目中缩短互联的设备之间的电缆长度。通常来说不应该使用200m 以上的双绞线，超过200m 的距离，就应该将电缆替换成光纤。\n而对于线路的噪音，局域网中各个设备网卡之间通常连接的双绞线就是为了抑制电磁波噪音干扰的，其中“双绞”的意思是以两根信号线为一组缠绕在一起。\n\n网线之外电磁波产生的影响 - 外源性噪声很多电器产品都会产生电磁波，例如电机、荧光灯、CRT 显示器、电磁炉等等。对于网线来说，这类电磁波干扰属于外源性噪声。\n\n首先，信号线是用金属做成的，当电磁波接触到信号线时，会沿电磁波传播的右旋方向产生电流，这种电流会导致波形发生失真。如果我们将信号线缠绕在一起，信号线就变成了螺旋形，其中两根信号线中产生的噪声电流方向就会相反，从而使得噪声电流相互抵消，噪声就得到了抑制（如下图）。\n\n\n网线内相邻网线产生的电磁波的影响 - 内源性噪声另一种电磁波是从网线中相邻的信号线泄漏的。由于电缆中信号本身就是一种电流，它也会相应的产生电磁波。虽然这种电磁波非常的微弱，但由于相邻的信号线之间距离过于靠近，这类电流也能产生出影响相邻信号线的电磁波。\n\n要抑制这种噪声，关键在于双绞线的缠绕方式。在一根网线中，每一对信号线的扭绞间隔（节距）都有一定的差异，这使得在某些地方正信号线距离近，另一些地方则是负信号线距离近。由于正负信号线产生的噪声影响是相反的，所以两者就会相互抵消。从网线整体来看，正负的分布保持平衡，自然就会削弱噪声的影响。（如下图）\n\n\n通过提升网线工艺来降低噪音影响例如在信号线之间加入隔板保持距离，以及在外面包裹可阻挡电磁波的金属屏蔽网等。\n\n\n\n类\n含义\n\n\n\n五类（CAT-5）\n用于 10 Mbit&#x2F;s（10BASE-T）和 100 Mbit&#x2F;s（100BASE-TX）以太网，可以最高 125 MHz 的频率在最长 100 米的距离内传输信号\n\n\n超五类（CAT-5e）\n用于千兆（1000BASE-T）以太网，对五类网线进行了改良，改善了串扰，也向下兼容 10BASE-T 和 100BASE-TX\n\n\n六类（CAT-6）\n支持最高 250 MHz 的信号传输，用于 1000BASE-TX 规格的千兆以太网和 10GBASE-T 规格的万兆以太网，同时向下兼容 10BASE-T、100BASE-TX 和 1000BASE-T\n\n\n超六类（CAT-6A）\n对六类网线进行了改良，改善了外部串扰，兼容 10GBASE-T、1000BASE-TX、1000BASE-T、100BASE-TX 和 10BASE-T\n\n\n七类（CAT-7）\n支持最高 600 MHz 的高速信号传输，兼容 10GBASE-T、1000BASE-TX、1000BASE-T、100BASE-TX 和 10BASE-T\n\n\n","tags":["读书笔记","网络技术","网络是怎样连接的"]},{"title":"交换机和路由器","url":"/2022/02/22/14.%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8/","content":"什么是交换机交换机是根据地址表进行包转发工作的设备。在传统交换机上（二层设备）交换机端口是不需要有MAC 地址的，所以交换机接到数据包后，无需检查目的MAC 地址是否是自己，而是在MAC 模块校验过数据包FCS 完整后直接将数据放到缓冲区。\n\n\n接下来交换机需要查询这个包的接收方MAC 地址是否已经存在与MAC 表中。MAC表包含两个信息：连接设备的MAC 地址和该设备连接的是哪个端口。这样接收方MAC 地址匹配到MAC 表中的地址信息后，交换机就知道将数据包从哪个接口发送出去。（如果目的MAC 地址不存在与MAC 表中，则交换机会将包原封不动的泛洪到其他端口，注意这里不是广播，广播会改变数据包的目的地址为全F；而收到泛洪报文的设备通常是PC，会检查目的MAC 地址是否是本机网卡的，不是的话直接丢失，是的话会进行对应的处理，从而保证数据发送到了正确的目的地）\n\n交换机交换电路的设计思路：交换机的输入端和输出端连接起来。其中信号线排列成网格状，每一个交叉点都有一个交换开关，交换开关是电子控制的，通过切换开关的状态就可以改变信号的流向。\n交换机可以同时执行多个转发操作，如上图，2号端口到7号端口的数据转发只使用了交换电路的一条同路，其他端口都是空闲的。空闲的端口可以是可以传输其他包的，因此相较于集线器，交换机是可以多个端口同时使用的。\n什么是路由器路由器是根据路由表（IP地址相关表）进行包转发工作的设备。通常来说，路由器面对的物理连接环境更为复杂（因为多数是与运营商连接，运营商环境复杂，具体能提供的物理线路类型并不固定），所以路由器通常由转发模块和端口模块两部分构成（交换机面对的连接情况比较单一，现在多为以太网链路，所以并不需要单独的端口模块；而选购路由器是需要选配不同接口模块，例如以太网接口模块、T1 接口模块，甚至无线模块等等，根据不同的网络连接类型选配不同的端口模块是路由器配置不可避免的一点）。\n路由器在转发包时，首先通过端口模块将对应通信技术的数据接收过来，并传递给转发模块。转发模块根据收到数据的IP 信息（即网络层头部信息）查询路由表，以此来判断需要将数据从哪个接口转发出去，将数据交给对应端口的端口模块。端口模块再将数据封装成符合端口规则的通信信息发送到下一个网络设备。\n与交换机相比，选配了以太网模块的路由器有一点很大的不同是，路由器接口在接收到以太网包时会查看目的MAC 地址是否是接口本身；同时路由器的接口还会配置IP 地址，而交换机不会这样工作（这里说的是二层交换机，而不是现在使用很多的三层交换机）。\n路由器也是通过查表判断转发目标的，在这一点上与交换机大体类似。但是具体的工作过程不同，交换机多数是通过以太网帧的目的MAC 地址来判断转发目标的，而路由器是通过网络层的IP 头部中的IP 地址来判断的（这里有两点需要注意，1. 并不一定通过目的IP 来判断转发目标，因为在网络层路径选择中有一种类型是”source routing”，可以由发送方指定数据包的前进路径抵达目的地；2. 也不一定是通过IP 地址来判断转发目标的，例如在MPLS 网络中，路由器是通过MPLS 标签来判断转发目标的）。\n同时，另一个不同是，交换机通过MAC 地址来判断转发目标，对于所有以太网设备而言，MAC 地址是一个固定长度（48 bits）的一个值，也就是说交换机判断目的地址使用的是一个定长值。而路由器通过IP 地址来判断转发目标时，不光要考虑IP 地址还需要考虑子网掩码等变长信息。（不定长信息带来结果就是判断转发目标带来的开销更大）\n\n交换机和路由器维护转发信息表的方法也不同。对于交换机来说，接收到的每一个包都会将包的源MAC 地址和对应的接口绑定写入MAC 地址表中。而对于路由器来说，对路由表的维护更为复杂，大致可以分为：1. 由人手工添加（静态路由）；2. 根据路由协议，在网络设备之间交换路由信息自动学习获得。\n","tags":["读书笔记","网络技术","网络是怎样连接的"]},{"title":"FTTH-光纤接入网","url":"/2022/03/23/16-FTTH-%E5%85%89%E7%BA%A4%E6%8E%A5%E5%85%A5%E7%BD%91/","content":"光纤的基本知识什么是光纤光纤的机构如下图，是一种双层结构的纤维状透明材质（玻璃和塑料）构成的。能够使用光纤中的纤芯传导光信号来传输数字信号。\n单模与多模不同材质的光纤因为透光率、折射率，线芯直径等因会影响光的传导。其中线芯直径对光的传导影响很大。对于光纤我们首先需要知道两点：\n\n入射角度过大的光线会在纤芯和包层的边界折射出去。这也就意味着光纤只能反射入射角较小的光信号； \n光也是波，因此光也具备相位。由于反射角产生的相位变化。当朝反射面前进的光和被反射回来的光交会，如果两条光线相位不一致，就会彼此发生干涉抵消。也就是说只有相位一致的光纤才会继续在光纤中传导（想象朝平静的睡眠水面扔石头，如果两边都有墙壁，那么向墙壁前进的水波与从墙壁返回的水波相交，相位相同则加强，不同则抵消）。这样，对于从光纤中传播的光信号，只有几个特定的角度入射的光信号，前进的光和被反射的光相位一致，所以只有特定角度入射的光线才能朝对端前进。 \n线芯的直径就是根据这些角度确定的。纤芯会极大地改变光纤的特性。 \n\n\n\n光纤根据纤芯的直径大小会划分成几种类型，大体包括单模光纤和较粗的多模光纤。\n单模光纤\n\n直径：8～10 μm；\n只有入射角很小的光线才能进入，可以说单模光纤的纤芯直径就是按照只允许相位一致的最小角度的光进入而设计的；\n能够通过的光线较少，因此对于光源和光敏元件的性能要求高，因此价格昂贵，这也会导致光信号失真较少\n信号失真还与光在纤芯传导时反射的次数有关。反射角越小，光线走过的距离越长。单模光纤可通信距离长。\n\n多模光纤\n\n直径：50μm 或 62.5μm\n多模光纤较粗，入射角比较大的光线也可以进入，这样，在相位一致的角度中，不仅入射角度小的光线能够通过，一些入射角度大的光线也能通过，即有多条光线在纤芯中同时传导。\n多条光线同时传导在多模光纤内也就意味着，对于设备来说光源和光敏元件的性能要求低，从而价格便宜；（相对于单模光纤信号失真会更大）\n反射角越大的光线，反射次数越多，走过的距离也就越长。光通过的距离会影响到达对端的时间，结果就是多条光线到达的时间不一致，信号的宽度就会被拉升，造成信号失真。所以多模光纤的可通信距离短。 \n\nFTTH 主要使用单模光纤。\n它的特性是怎么样的光信号的形成光信号的形成：数字信号 —&gt; 电信号 —&gt; 光信号\n\n这里的电信号很简单，高电压表示1，低电压表示0。通过将电信号输入LED、激光耳机光等光源后，这些光源根据信号电压的变化发光；1发光亮，0发光暗。\n光信号通过光纤传导到对端，在接收端有光敏元件来感应光纤明暗，光敏元件根据光的明暗产生不同的高低电压；最终电信号转换成数字信号，对端就接收到数据了。使用不同波长的光来区分上下行流量上下行光信号在光纤中混合在一起，信号会变得无法识别，因此需要对上下行流量进行区分，办法是使用不同波长的光来分别用在上下行光信号上。\n\n波长不同的光可以通过棱镜原理进行分离，因此光纤中的上下行流量即便混合到一起也可以被分开识别，像这样一条光纤中使用不同的波长传输多个光信号的方式叫做波分复用。\n与ADSL 相比较ADSL 由多频段、多波调制出信号形成电波；光信号，使用亮表示1、暗表示0。ADSL 将以太网帧拆分成信元发送到电话局的DSLAM（局端多路Modem）；用户端的发光设备将以太网电信号直接转换成光信号，光信号并没有重新封装以太网帧，可以认为以太网帧原原本本地转换成了光信号。\nFTTH 流程\nFTTH 接入如上图，大体分为两类。一种是一根光纤直接从用户端连接到最近的电话局。也就是光纤直连。另一种光纤的连接方式是在用户附近安装一个分光器设备，通过这个设备让光纤分路。这样做的主要目的是为了节省成本。因为分光器可以连接多个用户，然后复用一根到电话局的光纤。\nFTTH 使用光纤分路降低成本使用分光器的情况下，用户不再使用光纤收发器，而是使用一种叫做ONU（Optical Network Unit， 光网络但愿） 的设备。这个设备会为用户端提供光电信号转换的功能。\n在电话局这一端，光纤连接BAR 之前会先连接到OLT（Optical Line Terminal）设备上。\n这里需要注意的时，与光纤直连的接入方式相比，分光器和OLT 之间的光纤是多个用户共用的，因此，需要一种机制来避免多个用户同时收发网络包而产生信号碰撞。OLT 和ONU 具备通过调整信号收发的时机来避免碰撞的能力。\n具体来说，OLT 会调整信号发送时机并向ONU 下指令，ONU则根据OLT 的指令来发送数据。反过来，当BAR 向用户发送数据时，分光器只需要将信号发给所有用户就可以了，这里并不会发生碰撞，但是这样会使一个用户的数据传递到其他用户的网络中，早晨信息泄漏，因此需要在每个包前面加上用于识别ONU 的信息，当ONU 收到信号后，只会接收发给自己的光信号。\n\nONU: Optical Network Unit，光网络单元。它和光纤收发器一样，可以将电信号转换成光信号，除此之外还具有和电话局的OLT 相互配合避免信号碰撞的功能。这个设备也被称作终端盒，因此终端盒这个词本身是对光纤收发器和ONU 等光纤终端设备的统称。\n\n","tags":["读书笔记","网络技术","网络是怎样连接的"]},{"title":"17.使用ocserv 在Ubuntu 20.04 上搭建SSLVPN","url":"/2022/04/02/17-%E4%BD%BF%E7%94%A8ocserv-%E5%9C%A8Ubuntu-20-04-%E4%B8%8A%E6%90%AD%E5%BB%BASSLVPN/","content":"Why SSLVPN &amp; Why OcservSSLVPNSSLVPN 是一种简单且安全的远程隧道访问技术。采用了公钥加密的方式来保障数据在传输过程中的安全性，它采用浏览器和服务器直接沟通的方式，方便了用户又通过SSL 协议来保障了数据安全。SSL 协议采用了SSL&#x2F;TLS 综合加密的方法来保障数据安全。\nOcservOcserv 的主要优势有：\n\n开源，大家可以免费使用\n支持Cisco Anyconnect 客户端（稳定）\n客户端多平台支援\n服务器支持绝大部分Linux 和BSD\n支持密码认证和证书认证\n支持RADIUS 审计\n支持Virtual Hosting - 虚拟主机（Nginx - multi domain）\n部署简单\n\n前置需求\nUbuntu 20.04（1G RAM）\n公网IP 地址\n域名\n\n部署手册1. 安装Openconnect VPN Server使用ssh 登陆服务器，使用apt来安装ocserv\nsudo apt update -ysudo apt upgrade -ysudo apt install ocservsudo systemctl start ocserv\n\n安装完成后，使用命令检查服务状态：\nsudo systemctl status ocserv\n示例：\n2. 安装Let’s Encrypt Client（certbot）使用Let&#39;s Encrypt为VPN 服务器颁发证书。\n# install Let&#x27;s Encrypt Client - certbotsudo apt install certbot# check the versioncertbot --version# simple output: certbot 0.40.0# open firewall, prepare for next stepufw allow 80,443/tcp\n\n3. 通过Let‘s Encrypt 获取可信任TLS 证书主要有两种方式（standalone和webroot）为ocserv获取一个TLS 证书。\nStandalone如果没有网站部署在你的VPN 服务器上同时你也希望VPN Server 使用443 端口来监听远程接入，那么可以使用standalone插件来从Let’s Encrypt 获取TLS 证书。\n\n首先在DNS 服务提供商，将VPN 服务器的公网IP 绑定到准备好的域名上\n在VPN 服务器上使用命令获取证书\n\n\tsudo certbot certonly --standalone --preferred-challenges http --argee-tos --email youremail@email.com -d yourdomain.vpn.example.com# certonly: 获取证书但不安装# --standalone：使用standalone 插件来获取证书# --preferred-challenges http： 使用http 来检验域名，会使用80 端口，注意在上一步骤中将在服务器中将防火墙放通80/tcp 端口# --agree-tos：同意Let&#x27;s Encrypt 服务条款# --email：用来注册账户和账号恢复的邮箱# -d：你准备好的域名\n如果你看到如下图的信息，那么表示你已经成功获取到了TLS 证书：\n使用Webroot Plugin 获取证书推荐在VPN服务器同时部署了网站服务的时候使用这种方法，因为Webroot插件适用于几乎所有的Web服务器，我们不需要在Web服务器中安装证书。\n首先，需要在网页服务器中为域名创建一个虚拟主机（virtual Host）。\nNginx用熟悉的编辑器打开/etc/nginx/conf.d/yourdomain.vpn.example.com.conf\n将下列配置粘贴到文件中，并保存：\nserver &#123;      listen 80;      server_name vpn.example.com;      root /var/www/ocserv/;      location ~ /.well-known/acme-challenge &#123;         allow all;      &#125;&#125;\n\n执行下列命令：\n# 创建网站服务的root 目录sudo mkdir -p /var/www/ocserv# 将网站的root 目录权限设置给`www-data`（nginx default user）sudo chown www-data:www-data /var/www/ocserv -R# 重启nginx 服务sudo systemctl reload nginx\n\n然后使用let&#39;s encrypt后去TLS 证书：\nsudo certbot certonly --webroot --agree-tos --email youremail@example.com -d yourdomain.vpn.example.com -w /var/www/ocserv\n\n4. 编辑VPN 服务配置文件ocserv配置文件：/etc/ocserv/ocserv.conf\n配置认证方式默认情况下，ocserv使用PAM 组件来进行认证（也就是使用Linux 用户的账号和密码来认证），建议使用独立的账号密码作为VPN 的账号：\n# 在配置文件中，注释下面一行# auth = &quot;pam[gid-min=1000]&quot;# 使用一个文件来保存 VPN 用户的账号和密码auth = &quot;plain[passwd=/etc/ocserv/ocpasswd]&quot;# 完成配置文件后，我们会使用 ocpasswd 命令来创建/etc/ocserv/ocpasswd\n\n修改VPN 服务监听端口# 在配置文件中，注释下面两行#tcp-port = 443#udp-port = 443# 指定你希望的端口用作VPN 服务tcp-port = 4433udp-port = 4433\n\n修改VPN 使用的TLS 证书# 在配置文件中，注释下面两行# server-cert = /etc/ssl/certs/ssl-cert-snakeoil.pem# server-key = /etc/ssl/private/ssl-cert-snakeoil.key# 指定证书和密钥的文件，注意将vpn.example.com 替换成你的域名server-cert = /etc/letsencrypt/live/vpn.example.com/fullchain.pemserver-key = /etc/letsencrypt/live/vpn.example.com/privkey.pem\n\n设置最大客户端访问数量# 最大有128 个客户端可以连接VPN，设置为0 表示无限制max-clients = 128\n\n设置同一用户最大接入数量# 同一用户最大在线设备2，设置为0 表示无限制max-same-clients = 2 \n\n修改默认keepalive package 发送时间# 默认值为300s，建议改小keepalive = 30\n\n允许MTU 探测# 将下行false 改为true，以允许MTU 探测try-mtu-discovery = true\n\n设置客户端保持空闲时间# 如果你希望客户端不自动掉线，推荐下面两行配置idle-timeout=1200mobile-idle-timeout=1800\n\n设置默认域名default-domain = yourdomain.vpn.exmaple.com\n\n设置接入后获取的IP 网段# 因为很多家庭网络是用的是192.168.0.0/24 或192.168.1.0/24 推荐避开这两个段ipv4-network = 192.168.10.0ipv4-netmask = 255.255.255.0\n\nDNS 流量通过VPN 隧道tunnel-all-dns = true\n\n设置VPN 接入客户端使用的DNS 服务器# 根据实际情况选用合适的DNS 服务器，可以是内网DNS 服务器dns = 8.8.8.8dns = 1.1.1.1\n\n为个别网段设置VPN 服务器为默认网关# 连接服务器后，客户端会将10.0.0.0/8 和172.16.0.0/12 网段的网关设置为VPN 服务器route = 10.0.0.0/8route = 172.16.0.0/12# 如果要用VPN 服务器作为默认网关，取消掉下行注释# route = default\n\n修改配置后重启ocserv 服务sudo systemctl restart ocserv\n\n5. 创建VPN 账户使用ocpasswd 工具创建本地VPN 账号：\n# 将下列username 替换为用户账号sudo ocpasswd -c /etc/ocserv/ocpasswd username\n\n\n\n若需要使用 VPN 服务器作为代理服务器访问互联网，请参考以下链接。Set Up OpenConnect VPN Server (ocserv) on Ubuntu 20.04 with Let’s Encrypt (linuxbabe.com)\n\n","tags":["网络技术","运维"]},{"title":"ADSL 接入网","url":"/2022/03/13/15.ADSL-%E6%8E%A5%E5%85%A5%E7%BD%91/","content":"ADSL 接入网ADSL 接入网的构成（组件）\n用户侧在整个网络连接的过程中，用户侧是上图中最右侧的部分，包含了：\n\n用户计算机\n互联网接入路由器\nADSL Modem（调制解调器）\n分离器\n电话机\n\n各组件的功能互联网接入路由器提供拨号上网、NAT和路由的功能。\nADSL Modem（调制解调器）ADSL Modem 做了什么将路由器传输过来的以太网帧拆分为信元，并将信元调制成电信号传输到局端多路Modem。\n什么是信元ATM 交换和多路复用的基本单位，由信头和信息段组成，信头中装有控制信息，信息段中装入被分解成数据块的用户信息或其他管理信息。\n\n    \n    \n         信元的构造\n    \n            \n             Component\n             Description\n             length(bytes)\n        \n    \n    \n         \n             Header\n             装有控制信息\n             5\n         \n         \n             Payload\n             装有用户数据或其他管理信息\n             48\n         \n    \n\n\n\n\n 历史背景：    在开发ADSL 技术时，通讯业界比较看好ATM 技术，各运营商也在ATM 相关的设备上投入了很多资金。这种情况下，如果使用信元来传输数据，就比较容易和其他设备进行整合，可以降低开发投入和设备投入。所以如果不是出于这样的原因，其实不需要将包拆分成信元，实际上也有一些ADSL 运营商使用的ADSL Modem 是不进行数据拆分的。\n\n什么是调制ADSL Modem 内将数字信号转换为电信号（反之亦然）的技术被称之为调制。\n为何在ADSL 中要使用调制的方式来将数字信号转换为模拟信号在以太网中我们知道，数字信号也转换成了模拟信号，它使用了一种简单的方形波表示0和1。为什么在ADSL 技术中我们需要去开发另一个转换技术（调制技术）而不是复用简单的方波信号？\n主要有2点考量：\n\n方形波信号容易失真，无法在长距离的场景使用方形波信号的这种转换方式（网线有效距离一般在150m 左右，超过了就不推荐，甚至在华为的一些光转电模块中直接表明网线有效距离不能超过100m）\n方形波信号覆盖了从低频到高频的宽广频段，信号频率越高，辐射出来的电磁噪声越强，所以信号频谱太宽就难以控制噪声。\n\n调制技术原理：ADSL Modem 采用了一种用圆滑波形（正弦波） 对信号进行合成来表示0和1的技术，这种技术就是调制。\n调制技术有很多方式（例如：Wi-Fi 信号的调制），而ADSL Modem 采用的调制方式是振幅调制（ASK） 和相位调制（PSK） 相结合的正交振幅调制（QAM，也叫正交调幅）的方式。\n振幅调制（ASK）： 如下图中(b)，假设振幅小的信号为0，振幅大的信号为1，这是最简单的一种关系。在上图的例子中，振幅大小只有两个级别。如果增加振幅变化的级别，就可以对应更多的比特。例如，将振幅增加到4个级别，则振幅大小可以表示为00、01、10和11，这样就可以表示2个比特了。这样做可以将单位实际内传输的数据量加倍，也就能够提高速率。\n\n    \n    \n        理论携带比特\n    \n    \n        振幅级别\n        代表比特\n    \n    \n    \n        2\n        1\n    \n    \n        4\n        2\n    \n    \n        8\n        3\n    \n    \n        16\n        4\n    \n    \n        X\n        2x\n    \n\n\n\n\n不过信号在传输过程中会发生衰减，也会收到噪声影响而失真，如果振幅级别太多，接收方对信号的识别就容易出错，因此振幅级别需要维持在一个合理的值。\n\n相位调制（PSK）： 这是一种根据信号的相位来对应0和1 的方式。如下图所示，Modem 产生的信号以一定周期振动的波，振动的起始位置不同，波的形状也就不同。如果将波的一个振动周期理解为一个圆，则起始位置就可以用0 到360 度来表示，这个角度就是相位。例如，0度就是开始的波为0，从180度开始的波为1，这是最简单的一种对应关系。与振幅调制一样，相位调制也可以通过将角度划分为更细的级别来增加对应的比特数量，从而提高速率。当然与振幅调制一样， 太细的划分会造成接收端的误判，因此提升的速率还是有一定限度的。\n\n相位(phase)是对于一个波，特定的时刻在它循环中的位置：一种它是否在波峰、波谷或它们之间的某点的标度。是描述讯号波形变化的度量，通常以度（角度）作为单位，也称作相角。\n\nADSL 的调制方式： ADSL 的正交振幅调制就是将前面的两种方式组合起来实现的。如下图，如果信号的振幅表示1比特，相位也表示1比特，那么两种方式组合起来，正交振幅调制就可以用一个波表示更多的比特，从而提高传输速率。\nADSL 通过多波合成来提高速率在上一小节中我们描述了一个波（信号）使用正交振幅调制的方法将数字信号转换为电信号的原理。\n在实际中，这样的多个波（信号；注意这里的波是不同频率的波）可以合成在一起，然后在对端使用滤波器从合成的波中分离出某个特定频率的波（信号），从而在一个传输周期的信号中整合多个信号，将能够表示的比特数成倍提高。\nADSL 利用了这一特质，通过多个波增加能表示的比特数来提高速率。具体来说，ADSL 使用了间隔为4.3125 KHz 的上百个不同频率的波进行合成。\n每个波都使用了正交振幅调制技术，且每个波表示的比特数是可变的（噪声小、干扰小的波段分配更多比特）。这样每个频段表示的比特数加起来，就决定了整体的传输速率。\n上行下行速率不同\n\n\n\n方向\n频段数\n理论速率\n\n\n\n上行（用户到互联网）\n26\n1.3 Mbit&#x2F;s (Bins (carrier channels) - wikipedia)\n\n\n下行（互联网到用户）\n95&#x2F;223\n8 Mbit&#x2F;s (Bins (carrier channels) - wikipedia)\n\n\n\n一般而言，下行使用的频段较高，这些信号更容易衰减且容易收到噪声的影响。因此这些频段可表示的比特数少，或者干脆无法传输信号。距离越远，频率越高，这种情况越显著，因此如果用户李电话局太远，速率是无法得到保障的。\n\n正因为噪声和衰减对每个频段的信号影响不同，而且随时都在变化。因此，ADSL 会持续检查信号质量，动态地判断使用的频段数量，以及每个频段分配到的比特数。\n具体来说，就是Modem 通电后，会发送测试信号，并且根据信号的接收情况判断使用的频段数量和每个频段的比特数，这个过程被称为训练（握手），需要几秒到几十秒的时间。\n调制数据的传输线路和接口是什么样的线缆：copper telephone lines(铜质电话线)接口：通用电话线\n\n    \n        \n            线缆\n            接口类型\n        \n    \n    \n        \n            通用电话线\n            FXS 接口\n        \n        \n            FXO 接口\n        \n        \n            ADSL 接口\n        \n        \n            VDSL2 接口\n        \n    \n\n\nADSL 噪声控制虽然电话线和以太网双绞线的内部结构不同，但它们都是金属信号线，所以都会收到来自外部和内部的噪声，导致信号失真。而且，电话线在设计之初并没有考虑ADSL 的高频信号，这样看来电话线比以太网双绞线更容易收到噪声的干扰。\n但是与以太网双绞线不同的点在于，双绞线中只有一路方波信号，信号失真就会导致对端无法将电信号还原成原来的数字信号，导致通行错误。而ADSL 信号中是将多路波（信号）合成为一个信号，在多个频段的信号中，只有和噪声频率相同的信号会收到影响而无法读取，即可用的信号频段减少，结果是导致速率下降而非信号错误。\n外部干扰： 会导致速率下降。常见的外部干扰有：电网线路，AM 电台广播内部干扰： 在四芯线内部（如下图），或者相邻子单元的附近如果同时存在ADSL 和ISDN 线路，ISDN 发出的噪声会干扰ADSL（目前防止ISDN 干扰的技术已经成熟，基本无需担忧ISDN 线路干扰）\n\nADSL - G.992.1(G.dmt) - wikipedia\n分离器分离器只在接收对端电信号时产生作用，主要作用有2:\n\n过滤高频的ADSL 信号，将电话信号传给电话终端，保障电话的清晰度（不过滤电话信号，然后发给ADSL Modem 是因为，Modem 中具备过滤ADSL 频率外信号的功能）\n防止电话对ADSL 产生干扰：接通电话和断开电话两种状态下，信号的传输方式是不同的。两种状态会导致噪声等线路状态的改变，如果ADSL 通信过程中因为话机导致线路状态变化，就会引起ADSL 重新训练（握手），这样会导致几秒到几十秒的通信中断。\n\n\n在G.992.2 的ADSL 规格中已经有了新技术能够快速训练（握手），即使没有分离器也不会影响ADSL 通信。但是ADSL 的信号依然会影响电话信号，所以分离器是必不可少的一个组件。\n\n运营商侧运营商侧在ADSL 线路连接中可以细分为两大块。\n电话局在上图中，电话局位于“用户端电话局”框中，其中包含了：\n\n配线盘\n分离器\n电话交换机\n电话网\nDSLAM（局端多路Modem）\nBAS（Broadband Access Server，带宽接入服务器）\n\n各组件功能配线盘汇总每家每户电话线，并提供一定的防雷击装置。\n分离器与用户侧分离器功能一致。\n电话交换机DSLAM（局端多路Modem）将模拟信号（电信号）还原成数字信号（信元）。与用户端的ADSL Modem 功能大致相同，区别在于：\n\n同时连接多条线路，相当于将多个ADSL Modem 的功能集中到一个设备中。增加了空间使用率，并减少了运维管理的难度。\nDSLAM 一般不具备以太网口，而是ATM 接口。\nDSLAM 和后方路由器通信使用的是ATM 信元形式而非ADSL Modem 与路由器通信使用的以太网帧形式。\n\nBAS（Broadband Access Server）\n将 DSLAM 发来的信元转换为原始包；\n检查包头的MAC 头部、PPPoE 头部，无误后丢弃；\n添加隧道专用头部（一般情况下会使用L2TP 技术，这种情况下会添加L2TP 头部），并发送到隧道出口\n\nISPISP 为实际连接Internet 的服务机构，在整个为客户提供服务的ADSL 链路中包含了：\n\n路由器（隧道用）\n路由器\n认证服务器\n\n各组件功能路由器（隧道用）接收BAS 传递来的数据包，丢弃隧道头部，将IP 包取出，然后转发到互联网内部。\n路由器互联网内部路由，提供互联网路由服务。\nADSL 网络数据传输过程\n","tags":["读书笔记","网络技术","网络是怎样连接的"]},{"title":"19.DELL 服务器初始化","url":"/2022/05/02/19-DELL-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/","content":"服务器安装\n在服务器上，前面板配置iDRAC 地址\n\n在网页上使用该地址打开iDRAC 管理页面 \n\n使用iDRAC 默认账号: root 默认密码: calvin 登录系统，首次登陆会提示修改iDRAC 密码\n\n首页右下角有HTML 版本的控制台，点击打开 \n\n如果需要进行RAID 阵列卡配置，首先需要修改BIOS 启动配置，将其从UEFI 更改为BIOS\n\n保存BIOS 配置，重启系统，根据提示按ctrl + r 进入阵列卡配置界面，按需进行配置  有直通需求的硬盘需要在PD Mgmt 中修改为Non-RAID\n\n修改完配置，点击控制台软件，点击引用键盘宏”ctrl+alt+del” 重启机器 \n\n挂载虚拟截至（系统的ISO 文件），并在启动中将启动项修改为虚拟CD&#x2F;DVD&#x2F;ISO \n\n重启后注意查看启动是否为虚拟DVD，直通硬盘是否正常被识别。 \n\n等待一段时间，正式进入系统安装界面，下面是RHEL 7.6 的安装步骤。\n\n选择语言\n\n配置系统时间\n\n设置语言英文+中文的语言支持\n\n配置系统盘分区\n\n选择系统盘，选择手动分区，选择“Done” \n删除可能存在的已有分区，按照应用组要求，进行相应的系统盘分区 \n完成配置后，选择”Done“ 完成配置\n\n\n取消kdump\n\n开始安装，进行root 账号配置\n\n等待安装完成\n\n\n","tags":["运维","服务器"]},{"title":"HTTP 基础","url":"/2022/01/05/2.HTTP-%E5%9F%BA%E7%A1%80/","content":"前言这个系列的博客是针对阅读《网络是怎样连接的》（[日] 户根勤, 译 [中] 周自恒, ISBN: 9787115441249）一书的记录与思路整理。有些概念是做纯路由交换的网络工程师很少接触但又很重要的部分，因此整理到这里以做分享。\n\nHTTP 基本思路\nHTTP 协议定义了客户端和服务器之间交互的消息内容和步骤。\n\n客户端向服务器发送请求消息\n请求消息主要包含“对什么”和“怎么进行操作”\n“对什么”指的是URI，可以是一个网页数据的文件或者是一个CGI程序；也可以直接使用”http:”开头的URL 作为URI\n“怎么操作”指的是HTTP 方法，表示客户端希望web 服务器完成怎样的操作。例如，读取URI 表示的数据、将客户端输入的数据发送给URI 表示的程序等等\n请求信息还可以包含表示附加信息的头字段\n\n\n服务器解析请求，通过URI 和方法来判断“对什么”进行“怎样的操作”，并根据要求来完成自己的工作，然后将结果保存在响应消息中返回给客户端。\n响应消息的开头是一个状态码，用来表示操作的执行结果是成功还是发生了错误\n状态码之后就是字段和网页数据\n客户端收到后返回消息后，浏览器从消息中读取所需要的数据并展示在屏幕上。\n\n\n\nHTTP 方法\nGet 方法一般当我们访问 Web 服务器获取网页数据时，使用的就是 GET 方法。\nGet 方法的访问过程如下：\n\n在请求消息中国呢写上GET 方法，然后在URI 中写上存放网页数据的文件名”dir1&#x2F;file1.html”，这就表示我们需要获取”dir1&#x2F;file1.html” 文件中的数据。\n当web 服务器收到请求后，会打开”dir1&#x2F;file1.html” 文件并读取里面的数据，然后将读出的数据存放到响应消息中，返回给客户端。\n客户端收到数据，浏览器将数据展示到屏幕上。\n\nPost 方法在网页表单中填写的数据需要发送给服务器时，经常会使用到这个方法。\nPOST 访问过程如下：\n\nURI 会指向Web 服务器上的一个应用程序的文件名，例如”index.cgi” or “index.php”\n在请求消息中，除了方法和URI 之外，还要加上传递给应用程序和脚本的数据。如果是上传表单数据的话，这里就是用户在表单输入框中填写的信息\n服务器收到请求后，Web 服务器会将请求消息中的数据发送给URI 指定的应用程序\nWeb 服务器从应用程序接收输出的结果，将结果存放到响应消息中并返回给客户端。\n\nGET vs. POST\n\n\n\nGET\nPOST\n\n\n\n后退按钮&#x2F;刷新\n无害\n数据会被重新提交（浏览器应该告知用户数据会被重新提交）。\n\n\n书签\n可收藏为书签\n不可收藏为书签\n\n\n缓存\n能被缓存\n不能缓存\n\n\n编码类型\napplication&#x2F;x-www-form-urlencoded\napplication&#x2F;x-www-form-urlencoded 或 multipart&#x2F;form-data。为二进制数据使用多重编码。\n\n\n历史\n参数保留在浏览器历史中。\n参数不会保存在浏览器历史中。\n\n\n对数据长度的限制\n是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。\n无限制。\n\n\n对数据类型的限制\n只允许 ASCII 字符。\n没有限制。也允许二进制数据。\n\n\n安全性\n与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！\nPOST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。\n\n\n可见性\n数据在 URL 中对所有人都是可见的。\n数据不会显示在 URL 中。\n\n\n比较 GET 与 POST\nURI vs URLURIuniform resource identifier，统一资源标志符指的是在某一规则下能把一个资源独一无二地标识出来\nURLuniform resource locater，统一资源定位符指的是在某一规则下为一个资源提供找到该资源的路径\n可以看出URI 和URL 目的都是将一个资源标记出来，但是URL可以被看作是一个URI。因为还有一种URN可以作为URI 的另一种表现方法。\n目前Web 上最流行的就是URL，所以在某些场合我们可以认为URL约等于URI。\n生成HTTP 请求信息\n请求消息请求行结构为&lt;方法&gt;&lt;空格&gt;&lt;URI&gt;&lt;空格&gt;&lt;HTTP Version&gt;\n其中最为关键的就是&lt;方法&gt;了，它指明了服务器应当如何对客户端指定的URI进行操作操作。\n这里的关键问题在于，方法有很多种，该选用哪一种方法？\n解决这个问题的关键在于浏览器的工作状态。通常来说，在浏览器地址栏输入网址请求和点击网页中的超链接属于GET 方法。而在使用表单时，则根据HTML 源码中表单的属性指定使用哪种方法来发送请求，可能是GET 也有可能是POST。\n\n消息头消息头包含了关于请求额外的一些信息，例如：日期、客户端支持的数据类型、语言、压缩格式、客户端和服务器的软件名称和版本、数据有效期、最后更新时间等等。这些项目表示的都是非常细节的信息。\n\n消息体当使用POST 方法时，需要将表单中填写的信息写在消息体中。\n响应消息响应消息与请求消息大致类似，主要的不同在于第一行。\n状态行结构为&lt;HTTP 版本&gt;&lt;空格&gt;&lt;状态码&gt;&lt;空格&gt;&lt;响应短语&gt;状态码是一个数字，用来向程序告知服务器端的执行结果。响应短语是一段文字，用来向人告知执行结果。\n\n\n\n状态码\n含义\n\n\n\n1xx\n告知请求处理进度和情况\n\n\n2xx\n成功\n\n\n3xx\n表示需要进一步操作\n\n\n4xx\n客户端错误\n\n\n5xx\n服务器错误\n\n\n实例\n","tags":["读书笔记","网络技术","网络是怎样连接的"]},{"title":"18.开启PVE 宿主机的nested虚拟化","url":"/2022/04/02/18-%E5%BC%80%E5%90%AFPVE-%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%9A%84nested%E8%99%9A%E6%8B%9F%E5%8C%96/","content":"最近在使用Proxmox VE 平台为服务器提供虚拟化能力，顺便把EVE-NG 迁移到该平台，然后发现需要额外做一点工作来将CPU 的虚拟化功能expose 到Guest OS。以下是找到的相关资料和我在服务器上的操作记录整合。\n检查宿主机CPU 是否支持虚拟化检查PVE 宿主机是否开启嵌套虚拟化\nroot@proxmox:~# cat /sys/module/kvm_intel/parameters/nested   N\n\n显示N即尚未开启。进行如下操作开启嵌套虚拟化。\n对于Intel CPU 来说（自行查看CPU 是否支持）echo &quot;options kvm-intel nested=Y&quot; &gt; /etc/modprobe.d/kvm-intel.conf\n\n对于AMD CPU来说（自行查看CPU 是否支持）echo &quot;options kvm-amd nested=1&quot; &gt; /etc/modprobe.d/kvm-amd.conf\n\n针对自己的硬件平台执行完上述操作后，重启或重载内核模块。\n# 重载内核模块modprobe -r kvm_intelmodprobe kvm_intel\n\n推荐重启，省事。\n这时候再次检查，应该显示Y代表已开启。\nroot@proxmox:~# cat /sys/module/kvm_intel/parameters/nested                    Y\n\nNote: 注意什么时候用的是下划线******，什么时候用的是短横线********。**\n开启EVE 的虚拟化首先在PVE 的控制台或直接SSH 登陆主机，使用命令查看虚拟机。\n# 注意110 是虚拟机主机ID，在网页中可直接看到root@pve:~# qm showcmd 110 --pretty/usr/bin/kvm \\  -id 110 \\  -name EVE-NG-PRO \\  -no-shutdown \\  -chardev &#x27;socket,id=qmp,path=/var/run/qemu-server/110.qmp,server=on,wait=off&#x27; \\  -mon &#x27;chardev=qmp,mode=control&#x27; \\  -chardev &#x27;socket,id=qmp-event,path=/var/run/qmeventd.sock,reconnect=5&#x27; \\  -mon &#x27;chardev=qmp-event,mode=control&#x27; \\  -pidfile /var/run/qemu-server/110.pid \\  -daemonize \\  -smbios &#x27;type=1,uuid=a72029d4-c893-49c1-a9f3-cf50378eda30&#x27; \\  -smp &#x27;14,sockets=1,cores=14,maxcpus=14&#x27; \\  -nodefaults \\  -boot &#x27;menu=on,strict=on,reboot-timeout=1000,splash=/usr/share/qemu-server/bootsplash.jpg&#x27; \\  -vnc &#x27;unix:/var/run/qemu-server/110.vnc,password=on&#x27; \\  -cpu kvm64,enforce,+kvm_pv_eoi,+kvm_pv_unhalt,+lahf_lm,+sep \\  -m 61440 \\  -device &#x27;pci-bridge,id=pci.1,chassis_nr=1,bus=pci.0,addr=0x1e&#x27; \\  -device &#x27;pci-bridge,id=pci.2,chassis_nr=2,bus=pci.0,addr=0x1f&#x27; \\  -device &#x27;vmgenid,guid=8a062fe1-5c54-4382-8ef8-e0dc13e274f8&#x27; \\  -device &#x27;piix3-usb-uhci,id=uhci,bus=pci.0,addr=0x1.0x2&#x27; \\  -device &#x27;usb-tablet,id=tablet,bus=uhci.0,port=1&#x27; \\  -chardev &#x27;socket,id=serial0,path=/var/run/qemu-server/110.serial0,server=on,wait=off&#x27; \\  -device &#x27;isa-serial,chardev=serial0&#x27; \\  -device &#x27;VGA,id=vga,bus=pci.0,addr=0x2&#x27; \\  -device &#x27;virtio-balloon-pci,id=balloon0,bus=pci.0,addr=0x3&#x27; \\  -iscsi &#x27;initiator-name=iqn.1993-08.org.debian:01:dcfb1238fcc&#x27; \\  -device &#x27;lsi,id=scsihw0,bus=pci.0,addr=0x5&#x27; \\  -drive &#x27;file=/dev/pve/vm-110-disk-0,if=none,id=drive-scsi0,format=raw,cache=none,aio=io_uring,detect-zeroes=on&#x27; \\  -device &#x27;scsi-hd,bus=scsihw0.0,scsi-id=0,drive=drive-scsi0,id=scsi0,bootindex=100&#x27; \\  -netdev &#x27;type=tap,id=net0,ifname=tap110i0,script=/var/lib/qemu-server/pve-bridge,downscript=/var/lib/qemu-server/pve-bridgedown&#x27; \\  -device &#x27;e1000,mac=A6:A9:53:54:4F:F8,netdev=net0,bus=pci.0,addr=0x12,id=net0&#x27; \\  -machine &#x27;type=pc+pve0&#x27;\n\n拷贝得到的输出到编辑器中，找到其中-cpu kvm64,enforce,+kvm_pv_eoi,+kvm_pv_unhalt,+lahf_lm,+sep\n在其后添加+vmx，即：\n/usr/bin/kvm \\  -id 110 \\  -name EVE-NG-PRO \\  -no-shutdown \\  -chardev &#x27;socket,id=qmp,path=/var/run/qemu-server/110.qmp,server=on,wait=off&#x27; \\  -mon &#x27;chardev=qmp,mode=control&#x27; \\  -chardev &#x27;socket,id=qmp-event,path=/var/run/qmeventd.sock,reconnect=5&#x27; \\  -mon &#x27;chardev=qmp-event,mode=control&#x27; \\  -pidfile /var/run/qemu-server/110.pid \\  -daemonize \\  -smbios &#x27;type=1,uuid=a72029d4-c893-49c1-a9f3-cf50378eda30&#x27; \\  -smp &#x27;14,sockets=1,cores=14,maxcpus=14&#x27; \\  -nodefaults \\  -boot &#x27;menu=on,strict=on,reboot-timeout=1000,splash=/usr/share/qemu-server/bootsplash.jpg&#x27; \\  -vnc &#x27;unix:/var/run/qemu-server/110.vnc,password=on&#x27; \\  -cpu kvm64,enforce,+kvm_pv_eoi,+kvm_pv_unhalt,+lahf_lm,+sep,+vmx \\  -m 61440 \\  -device &#x27;pci-bridge,id=pci.1,chassis_nr=1,bus=pci.0,addr=0x1e&#x27; \\  -device &#x27;pci-bridge,id=pci.2,chassis_nr=2,bus=pci.0,addr=0x1f&#x27; \\  -device &#x27;vmgenid,guid=8a062fe1-5c54-4382-8ef8-e0dc13e274f8&#x27; \\  -device &#x27;piix3-usb-uhci,id=uhci,bus=pci.0,addr=0x1.0x2&#x27; \\  -device &#x27;usb-tablet,id=tablet,bus=uhci.0,port=1&#x27; \\  -chardev &#x27;socket,id=serial0,path=/var/run/qemu-server/110.serial0,server=on,wait=off&#x27; \\  -device &#x27;isa-serial,chardev=serial0&#x27; \\  -device &#x27;VGA,id=vga,bus=pci.0,addr=0x2&#x27; \\  -device &#x27;virtio-balloon-pci,id=balloon0,bus=pci.0,addr=0x3&#x27; \\  -iscsi &#x27;initiator-name=iqn.1993-08.org.debian:01:dcfb1238fcc&#x27; \\  -device &#x27;lsi,id=scsihw0,bus=pci.0,addr=0x5&#x27; \\  -drive &#x27;file=/dev/pve/vm-110-disk-0,if=none,id=drive-scsi0,format=raw,cache=none,aio=io_uring,detect-zeroes=on&#x27; \\  -device &#x27;scsi-hd,bus=scsihw0.0,scsi-id=0,drive=drive-scsi0,id=scsi0,bootindex=100&#x27; \\  -netdev &#x27;type=tap,id=net0,ifname=tap110i0,script=/var/lib/qemu-server/pve-bridge,downscript=/var/lib/qemu-server/pve-bridgedown&#x27; \\  -device &#x27;e1000,mac=A6:A9:53:54:4F:F8,netdev=net0,bus=pci.0,addr=0x12,id=net0&#x27; \\  -machine &#x27;type=pc+pve0&#x27; \\  -cpu kvm64,enforce,+kvm_pv_eoi,+kvm_pv_unhalt,+lahf_lm,+sep,+vmx\n\n复制所得，然后在PVE 的CLI 界面使用该命令，启动VM 110 （EVE-NG）。\n使用qm list 查看虚拟机状态，\noot@pve:~# qm list      VMID NAME                 STATUS     MEM(MB)    BOOTDISK(GB) PID              110 EVE-NG-PRO           running    61440              0.00 1434 \n\n显示虚拟机已经启动。\n这是登陆到虚拟机的CLI 界面，使用egrep &quot;vmx|svm&quot; /proc/cpuinfo flags，查看是否成功在虚机中启动虚拟化。\nroot§eve-ng:ß# egrep &quot;vmx|svm&quot; --color=always /proc/cpuinfo      flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx lm constant_tsc nopl xtopology cpuid tsc_known_freq pni vmx cx16 x2apic hypervisor lahf_lm cpuid_fault tpr_shadowflags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx lm constant_tsc nopl xtopology cpuid tsc_known_freq pni vmx cx16 x2apic hypervisor lahf_lm cpuid_fault tpr_shadowflags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx lm constant_tsc nopl xtopology cpuid tsc_known_freq pni vmx cx16 x2apic hypervisor lahf_lm cpuid_fault tpr_shadowflags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx lm constant_tsc nopl xtopology cpuid tsc_known_freq pni vmx cx16 x2apic hypervisor lahf_lm cpuid_fault tpr_shadowflags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx lm constant_tsc nopl xtopology cpuid tsc_known_freq pni vmx cx16 x2apic hypervisor lahf_lm cpuid_fault tpr_shadowflags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx lm constant_tsc nopl xtopology cpuid tsc_known_freq pni vmx cx16 x2apic hypervisor lahf_lm cpuid_fault tpr_shadowflags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx lm constant_tsc nopl xtopology cpuid tsc_known_freq pni vmx cx16 x2apic hypervisor lahf_lm cpuid_fault tpr_shadowflags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx lm constant_tsc nopl xtopology cpuid tsc_known_freq pni vmx cx16 x2apic hypervisor lahf_lm cpuid_fault tpr_shadowflags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx lm constant_tsc nopl xtopology cpuid tsc_known_freq pni vmx cx16 x2apic hypervisor lahf_lm cpuid_fault tpr_shadowflags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx lm constant_tsc nopl xtopology cpuid tsc_known_freq pni vmx cx16 x2apic hypervisor lahf_lm cpuid_fault tpr_shadowflags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx lm constant_tsc nopl xtopology cpuid tsc_known_freq pni vmx cx16 x2apic hypervisor lahf_lm cpuid_fault tpr_shadowflags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx lm constant_tsc nopl xtopology cpuid tsc_known_freq pni vmx cx16 x2apic hypervisor lahf_lm cpuid_fault tpr_shadowflags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx lm constant_tsc nopl xtopology cpuid tsc_known_freq pni vmx cx16 x2apic hypervisor lahf_lm cpuid_fault tpr_shadowflags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall nx lm constant_tsc nopl xtopology cpuid tsc_known_freq pni vmx cx16 x2apic hypervisor lahf_lm cpuid_fault tpr_shadow\n\n将VMX参数添加为默认启动项在PVE 的host 机中，编辑需要启动vmx的主机的配置文件。文件存放于/etc/pve/qemu-server下。\n修改对应vm-id 的配置文件，在这里需要修改的文件是110.conf\n在第一行添加args: -cpu &#39;kvm64,enforce,+kvm_pv_eoi,+kvm_pv_unhalt,+lahf_lm,+sep,+vmx&#39;（注意该命令请通过qm showcmd 110 —pretty命令，找到CPU 选项的一行，手动添加+vmx），保存。通过网页启动110 虚机时无需再通过命令行手动添加vmx启动选项启动guest virtualization nest。\n","tags":["运维","Proxmox VE","虚拟化"]},{"title":"20.CentOS7.4 安装宕机","url":"/2022/05/02/20.CentOS7.4%E5%AE%89%E8%A3%85%E5%BC%82%E5%B8%B8-starting%20dracut%20initqueue%20hook/","content":"CentOS 7.4 安装中出现此问题：[ok] starting dracut initqueue hook\n网上找到一篇文章[centos7.4 U盘安装卡在 starting dracut initqueue hook_·&#96;米笵6的技术博客_51CTO博客](https://blog.51cto.com/mifan6/2070118)，解决了故障。\n到下一行就不动了，一直没有反应！那我们现在来解决这问题：\n第一步插上引导U 盘，重启设备，到达启动界面后选择“install CentOS 7” 不要回车，直接按键盘“e”\n出现下面的默认信息：\nsetparams &#x27;Install CentOS Linux 7linuxefi  /images/pxeboot/vmlinuz inst.stege2=hd:LABEL=CentOS\\x207\\x20x\\86_64 rd.live.check quletinitrdefi /images/pxeboot/initrd.img\n\n修改第二行：\nsetparams &#x27;Install CentOS Linux 7linuxefi  /images/pxeboot/vmlinuz linux dd nomodeset quletinitrdefi /images/pxeboot/initrd.img\n修改完成后，按住键盘”ctrl”+”x” 执行代码，进入下一阶段\n第二步这一步的主要目的是寻找U 盘的盘符，注意LABEL 类似CENTOS7 的项。\n可以看到sdb4 就是我们的U 盘，记录U 盘位置。有的时候可能会存在U此时应该是/dev/sdb4\n第三步再次重启，到达启动界面后选择“install CentOS 7” 不要回车，直接按键盘“e”\n这次我们将默认信息做如下修改：\nsetparams &#x27;Install CentOS Linux 7linuxefi  /images/pxeboot/vmlinuz inst.stage2=hd:/dev/sdb4 nomodeset quletinitrdefi /images/pxeboot/initrd.img\n\n\n需要注意hd: 后面的部分按照实际情况填写U 盘位置\n\n修改完成后按住”ctrl”+”x” 执行代码，就能进入到正常的安装界面。\n","tags":["运维","Linux"]},{"title":"DNS","url":"/2022/01/06/3.DNS/","content":"前言这个系列的博客是针对阅读《网络是怎样连接的》（[日] 户根勤, 译 [中] 周自恒, ISBN: 9787115441249）一书的记录与思路整理。有些概念是做纯路由交换的网络工程师很少接触但又很重要的部分，因此整理到这里以做分享。\n\n域名和IP 地址并用的理由TCP&#x2F;IP 网络必须使用IP 地址来确定通信对象。那为什么作为用户时，很少会碰到直接使用IP 地址的时候，例如访问网页使用的是域名？\n\n域名方便记忆。实际上使用IP 地址来替代网址也是可以工作的。（实际上当今的服务器软件如果启用了虚拟主机功能，直接使用IP 地址也无法访问）\n运行效率。IP 地址长度为32 bits，即4 bytes。域名大小不定从十几到255字符都是有可能的。如果通过域名来决定如何处理数据包，不仅增加了网络中路由器的负担（域名长度是不固定的。处理长度不固定的数据比处理定长的数据要复杂得多，负担也更重），还减缓了数据传递的速度（因为传递的数据量更大了）\n域名可以使系统具备容灾、负载均衡特性，例如一个域名可以对应多个后台IP，那么我们通过操作DNS 系统就可以将流量负载到不同的后台设备（书上没有，自己补充）\n\n所以当前，互联网使用的方案是让人来使用域名&#x2F;网站名称，让机器来使用IP 地址。\n为了填补域名和IP 地址之间的障碍，我们需要一个机制能够让机器通过名称来查询IP 地址，反之亦然。这个机制就是DNS。\nDNS什么是DNSDNS：Domain Name System，域名服务系统。将服务器名称和IP 地址进行关联是DNS 最常见的用法。但DNS的功能并不仅限于此，例如可以将邮件地址和邮件服务器关联，以及为各种信息关联相应的名称。\nSocket 库提供查询IP 地址的功能通过DNS 查询IP 地址的方法非常简单，机器只需要询问最近的（指定的）DNS 服务器“www.xxxx.com 的IP 地址是什么”就可以了。 \n既然有服务器，那么主机上也一定会有客户端。DNS 的客户端被成为DNS 解析器、或者简称解析器。通过DNS 查询IP 地址的操作成为域名解析，负责执行解析（resolution）操作的就叫解析器（resolver）。解析器实际上是一段程序，包含在操作系统Socket 库中。\n\n“Socket 库是在加州大学伯克利分校开发的 UNIX 系操作系统 BSD 中开发的 C 语言库，互联网中所使用的大多数功能都是基于 Socket 库来开发的。因此，BSD 之外的其他操作系统以及 C 语言之外的其他编程语言也参照 Socket 库开发了相应的网络库。可以说，Socket 库是网络开发中的一种标准库。” - 摘录来自: ［日］ 户根勤. “网络是怎样连接的。” \n\n浏览器完成DNS 查询的全流程\nDNS 服务器的基本工作DNS 服务器的基本工作就是，接收来自客户端的查询消息，然后根据消息的内容进行返回响应。\n客户端的查询消息包含3类信息：\n\n\n\n信息类型\n备注\n\n\n\n域名\n服务器的名称邮件服务器（邮件地址中@ 后面的部分）的名称\n\n\nClass\n最早设计DNS 方案时，DNS 在互联网以外的其它网络中的应用也被考虑到了。如今，除了互联网并没有其它网络用到DNS 了，所以Class 的值永远为IN\n\n\n记录类型\n表示域名对应何种类型的记录。例如，A 型（Address 的缩写），表示域名对应的是IP 地址。MX 型，表示域名对应的是邮件服务器。\n\n\n\n\n上图中，DNS 信息以表格的形式表现，表格中的每一行信息被称为一条资源记录。实际上数据是保存在服务器的配置文件中。\n\n示例DNS 服务器包含以下记录\n\n\n\n域名\nClass\n记录类型\n相应数据\n\n\n\nwww.lab.glasscom.com\nIN\nA\n192.0.2.226\n\n\nglasscom.com\nIN\nMX\n10 mail.glasscom.com\n\n\nmail.glasscom.com\nIN\nA\n192.0.2.227\n\n\n查询www.lab.glasscom.com 域名的IP 地址客户端向DNS 服务器发送以下信息\n\n\n\n域名\nClass\n记录类型\n\n\n\nwww.lab.glasscom.com\nIN\nA\n\n\nDNS 服务器查找已有记录，第一条的三个项目完全匹配。则DNS服务器将记录的192.0.2.226 返回给客户端。\nWeb 服务器的域名很多都以www 开头，这只是一种惯例而已。无论是Webserver1 或MySrv 也好，只要是作为A记录在DNS 服务器上注册，都可以作为Web 服务器的域名。同理，对于其它类型的服务器（邮件、数据库等），只要注册了A类型，就可以作为服务器的域名来使用。\n查询tone@glasscom.com 域名的IP客户端向DNS 服务器发送以下信息\n\n\n\n域名\nClass\n记录类型\n\n\n\nglasscom.com\nIN\nMX\n\n\n服务器会返回邮件服务器的域名和优先级。同时还会返回邮件服务器域名的IP 地址。\n\n当一个邮件地址对应多个邮件服务器时，需要根据优先级判断哪个邮件服务器是优先的。优先级数值越小代表邮件服务器更优先。\n\n一个DNS 响应抓包\nDNS 记录类型\n\n\n记录类型\n备注\n\n\n\nA\n查询IP\n\n\nMX\n查询邮件服务器\n\n\nPTR\n根据IP地址反查域名\n\n\nCNAME\n查询域名相关别名\n\n\nNS\n查询DNS服务器IP地址的NS类型\n\n\nSOA\n查询域名属性信息\n\n\n域名的层次结构在有限的服务器的情况下，一台DNS 服务器按照上述的模式为主机提供解析服务。但是在互联网环境下，将全球所有的域名信息都记录在一台服务器上显然是不现实的，这时我们将DNS 信息分布式保存在多台DNS服务器中，并通过DNS 服务器互相接力配合来找出主机查询的信息。\nDNS 服务器中的所有信息都是按域名以分层次的结构来保存的。DNS 域名都是通过句点来分隔的，句点就代表了不同层次之间的界限。\n在域名中，越靠右的位置表示其层级越高。举例来说www.lab.glasscom.com这个域名如果按照公司的组织架构来说，com 就是集团总部，glasscom是集团总部下面的子公司，lab是子公司内的一个部门，www就是部门中的科室。\n对于域名存储来说，注意几点：\n\n每个域都是作为一个整体来处理的。也就是说一个域的信息是作为一个整体存放在DNS 服务器中，不能将一个域拆开来存放在多个服务器；\n一台DNS 服务器中可以存放多个域信息；\n现在管理员是通过创建子域（下级域）来分配给不同的公司、组织和个人的。\n\n寻找合适的DNS 服务器并获取期望的IP 地址过程\n首先将管理下级域的DNS 服务器注册到它们的上级DNS 服务器中；\n然后将上级DNS服务器注册到更上一级DNS 服务器，以此类推；\n这样我们就可以通过上级DNS 服务器查询出下级DNS 服务器发送查询请求了。\n\n\n根域要记住com、jp、cn并非最上级的域，在之上还有一层根域。\n如果要明确表示根域就需要在域名后面加上.，例如www.lab.glasscom.com.\n根域的DNS 保存着com、jp、cn等DNS服务器的信息。根域的另一项工作，就是将根域的DNS 服务器信息保存在互联网上所有的DNS 服务器中。这样一来，在最坏的情况下，任何DNS 服务器也都可以通过访问根域来找到任意一台DNS 服务器获取期望信息。这项工作并不困难，原因有两点：\n\n全球只有13个根域DNS IP，且基本不发生变化；\n根域DNS 服务器相关信息包含在DNS 服务器程序的配置文件中了，因此安装了DNS 服务器程序，这些信息会自动配置好（除非手动删除）\n\nDNS 服务器工作流程\n客户端向本机配置好的DNS 服务器（本地DNS 服务器）发起请求，询问www.lab.glasscom.com 的IP地址是多少？\n本地DNS服务器没有保存相关信息，因此本地DNS 服务器将请求转发给根域DNS服务器\n根域也没有详细信息，但是根域查找到管理com域的DNS 服务器地址，因此根域返回它保存的管理com域的DNS 服务器IP\n本地服务器继续向管理com域的DNS服务器请求解析\n管理com域的DNS 服务器也没有保存www.lab.glasscom.com的信息，但是它找到了下级域glasscom.com的管理DNS 服务器，因此它返回下级域IP\n客户端继续向下级域进行解析请求，最终找到存放www.lab.glasscom.com的DNS服务器，获取到www.lab.glasscom.com 的IP 地址\n\n\n\n但在实际情况下，很多时候上下级域可能共享同一台DNS服务器，所以DNS服务器收到一个请求后，该服务器会返回当前服务器最下级的数据给客户端。\n\nDNS 缓存很多时候本地DNS 服务器不需要从根域开始进行DNS 查找，这是因为DNS 服务器有一个缓存功能，可以记住之前查询过的域名。如果要查询的域名和相关信息已经在缓存中，那么可以本地DNS服务器可以直接返回结果。节约了用户的请求时间。\n相对的，一个域名被缓存在某个DNS 服务器时，其真实DNS 信息有可能已经修改，这时缓存信息就有可能不正确。DNS 服务器对每个缓存都用设置了一个有效期，当缓存信息超过有效期后，数据就会从缓存中删除。另外，当DNS 服务器使用缓存数据向客户端进行回应时，DNS 服务器也会告知客户端这一响应结果来自缓存而不是负责管理该域名的DNS 服务器。\n","tags":["读书笔记","网络技术","网络是怎样连接的"]},{"title":"21.ICMP 协议浅析","url":"/2022/05/02/21-ICMP-%E5%8D%8F%E8%AE%AE%E6%B5%85%E6%9E%90/","content":"ICMPICMP: Internet Control Message Protocol互联网控制信息协议是IP 层的一个辅助协议。用来在网络设备传递各种差错和控制信息。\n常用的ICMP 类型\n\n\n\nType\nCode\nDescription\n\n\n\n0\n0\nEcho Reply\n\n\n3\n0\n网络不可达\n\n\n3\n1\n主机不可达\n\n\n3\n2\n协议不可达\n\n\n3\n3\n端口不可达\n\n\n5\n0\n重定向\n\n\n8\n0\nEcho Request\n\n\nICMP 重定向ICMP重定向报文是ICMP 控制报文的一种。\n\n\n\nType\nCode\nDesc\n\n\n\n5\n0\nredirect datagrames for the Network\n\n\n5\n1\nredirect datagrames for the Host\n\n\n5\n2\nredirect datagrames for the Type of Service and Networks\n\n\n5\n3\nredirect datagrames for the Type of Service and Host\n\n\nSteps:\n\n主机A 10.0.0.1&#x2F;24希望前往服务器A 20.0.0.1&#x2F;24，因为在不同网段，主机A 将数据包发送到默认网关RTB\n网关RTB 查询路由表后发现，目标地址20.0.0.1 的下一跳在RTA 10.0.0.200，这时RTB 监测到RTA 与数据包的源地址10.0.0.1 在同一网段，RTB 会向主机A 发送ICMP 重定向报文，告知主机A 去往20.0.0.1&#x2F;24 的流量可以直接发送到RTA，因为这是前往服务器A 的最短路径\n主机A 接下来发往服务器A 的流量都直接发往同网段的RTA\n\n\n对于具有IP源路由选项和目的地地址字段中的网关地址的数据报，即使存在比源路由中的下一个地址更好的到达最终目的地的路由，也不会发送重定向消息。\n\n抓包主机A 发往默认网关10.0.0.1 的数据包无回复；默认网关发送ICMP Redirect 到主机A，告知主机A 去往20.0.0.2 的数据包直接发往10.0.0.200\n主机A 重新发送去往20.0.0.2 的数据包，这次下一条用的是10.0.0.200，可以从二层的MAC 地址看出；同时这次发送的request 包，收到正常的reply 回包。\n发送ICMP redirect 条件满足下列所有条件，则路由器会发送ICMP redirect 信息：\n\n数据包进入路由器的接口与数据包路由出的接口相同。\n源IP地址的子网或网络与所路由的数据包的下一跳IP地址位于同一子网或网络上。\n该数据报不携带源路由信息。\n内核配置为发送重定向。\n\nICMP 错误报告ICMP 定义了各种错误消息，用户诊断网络连接性问题；根据这些错误消息，源设备可以判断出数据传输丢失的原因。\n\n\n\nType\nCode\nDesc\n\n\n\n3\n0\nnet unreachable, send by gateway\n\n\n3\n1\nhost unreachable, send by gateway\n\n\n3\n2\nprotocol unreachable, send by destination host\n\n\n3\n3\nport unreachable, send by destination host\n\n\n3\n4\nfragmentation needed and DF set, send by gateway\n\n\n3\n5\nsource route failed, send by gateway\n\n\nnet unreachable根据网关路由信息，目的网络不可达时，网关会向源主机发送destination unreachable 信息。\nprotocol unreachable如果目标主机的IP 模块无法正常工作，则目标主机会向源主机回复protocol unreachable\nfragmentation needed and DF set如果网络设备转发报文需要对报文分片，而IP 的DF 位设置为1，则网关丢弃报文，同时发送fragmentation needed and DF set 信息给源主机。\nICMP 超时报文\n\n\n\nType\nCode\nDesc\n\n\n\n11\n0\ntime to live exceeded in transit\n\n\n11\n1\nfragment reassembly time exceeded\n\n\nTTL 传输超时如果在网络设备转发报文时，TTL 字段为0，则网络设备丢弃报文同时向源设备发送ICMP 超时信息 time to live exceeded in transit\nIP 重组超时如果正在重组分段数据报的主机由于在其时间限制内丢失片段而无法完成重组，则它将丢弃该数据报，并且它可能发送fragment reassembly time exceeded消息。\n源抑制消息 - Source Quench Message\n\n\n\nType\nCode\nDesc\n\n\n\n4\n0\nSource Quench Message\n\n\n\n互联网线路上的网络设备若没有足够的buffer 来存储需要转发的数据包，那么在丢弃数据包前，网络设备可以向源设备发送源抑制消息。\n目标设备若收到太多数据包而无法处理，可以向源设备发送源抑制消息。\n\n收到源抑制消息的源主机应该降低向指定目的地发送流量的速率，直到它不再从网络或目标主机接收到源抑制消息。然后，源主机可以逐渐提高向目的地发送流量的速率，直到再次收到源抑制消息。\n","tags":["网络技术"]},{"title":"三大表初探","url":"/2022/01/06/4.%E4%B8%89%E5%A4%A7%E8%A1%A8%E5%88%9D%E6%8E%A2/","content":"前言这个系列的博客是针对阅读《手把手教你读财报》（[中] 唐朝, ISBN: 9787513649551）一书的记录与思路整理。目前正在学习股市基本面的一些知识，通过这个系列的博客与大家分享投资理财，股市基本面的内容。我认为选股是靠基本面来支撑的，而买卖的时机则是技术分析的优势。希望能通过这样的整理，帮助自己深入地理解财报之中的奥妙，也能为对此类话题有兴趣的读者提供一些微不足道的帮助。\n\n时间财报时间\n\n\n\n披露时间\n备注\n\n\n\n经营年度\n\n自然年（1月1日至12月31日）\n\n\n一季报\n一季度结束一个月内\n不得早于年报\n\n\n半年报\n8月底之前\n\n\n\n三季报\n10月底\n\n\n\n年报\n年度结束4个月内\n必须经会计师事务所审计并出具审计意见\n\n\n预报时间上海证券交易所在法定的季报、半年报和年报发布之前，某些情况下，上市公司还需要按照交易所要求，提前发布业绩预告或业绩快报。\n\n\n\n情形\n时间\n\n\n\n亏损\n1&#x2F;31\n\n\n扭亏为盈\n1&#x2F;31\n\n\n实现盈利\n1&#x2F;31\n\n\n深圳证券交易所\n\n\n情形\n补充\n时间\n\n\n\n亏损\n\n季报、半年报及年报前\n\n\n扭亏为盈\n\n季报、半年报及年报前\n\n\n实现盈利，且净利润同比上升或下降50% 以上\n但上年同期基数较小，可申请豁免披露。\n\n\n\n基数较小定义为：上年度每股收益不高于0.05 元，或上一年前三季度每股不高于0.04 元，或上一半年度每股收益不高于0.03 元，或上一年第一季度每股收益不高于0.02 元\n季报、半年报及年报前\n\n\n\n期末净资产为负值\n\n季报、半年报及年报前\n\n\n年度营业收入低于1000 万人民币\n\n季报、半年报及年报前\n\n\n母公司概念“母公司”只是表达公司之间互相关系，不是固定指谁。\n例如，A公司持有B 公司的60% 股权，B 公司持有C公司80%股权，C 持有D 51% 股权。那么A是B的母公司，B是C的母公司，C是D 的母公司。\n在财报中，“母公司资产负债表”、“母公司利润表”、“母公司现金流表”以及“母公司所有者权益变动表”，特指上市公司本部数据。除此之外，财报其它地方用到“母公司”，指的是上市公司的控股股东。\n资产负债表\n资产：钱的去向常见形态有：厂房、设别、土地；投资、股票、理财产品；投入其他公司化作股份等等\n负债和股东权益：钱的来源有借的：即负债股东投的：股东权益\n因为钱不会无中生有，所以钱的来源和去向，总额永远相等。\n有恒等式：资产&#x3D;负债+股东权益也可以写作：股东权益 &#x3D; 资产 - 负债，股东权益也被成为“净资产”\n各项在表中的排列顺序钱的去处即公司资产，按变现（变成现金）便捷度排列：现金、银行存款等构成货币资金位于资产负债表最上固定资产、无形资产、商誉等放在资产负债表最下\n流动资产：能在一年（或一个营业周期）内变现越容易越上非流动资产：超过一年（或一个营业周期）变现越难越下\n钱的来源按归还的紧迫程度排列：所以负债在上、股东权益在下\n负债又分为：流动负债：债务到期时间是段于一年（或该企业的一个营业周期），越近越上非流动负债：债务到期时间超过一年（或该企业的一个营业周期），越远越下\n阅读资产负债表的原则\n资产端和负债端各项进行腾挪，想想为什么这么做，做的对不对\n和过去的数据进行对比，揣测公司为什么这么变\n和同行的数据进行对比\n思考不同类型的资产在总资产中占比有何不同\n为何不同\n不同处是优势还是劣势\n对比应收票据、应收账款、应付账款、预付款项、预收款项等科目，发现公司在其行业上下游之间的地位，思考公司的竞争力强弱\n\n\n\n利润表“权责制”-财务造假的“温床”什么是“权责制”“权责制”又称“应收应付制”，是以权利或责任的发生来确定“应该得到的收入”和“应该支付的费用”，而不是考虑实际是否收到或支出的现金。\n示例甲公司支付100万购买一辆火车给其它企业提供运输服务。预计车辆能使用5年，那么按照“权责制”，现在甲公司已经支付出去的100万车款，要分摊在5年里作为甲公司的费用支出，而非全部算成当年的费用。同理，若合同约定运输费用为每季度结算一次，季度结束的10个工作日内结算，那么到财年结束12月31日，虽然第四季度运输费用并没有收到，但甲公司依然要将第四季度的运输费作为本年度收入计入。简单来说，依照“权责发生制”，没有收到的钱，可能被算作本期收入；没有付出的钱，可能被记为本期成本。已经收到的钱，可能不是本期收入；已经支付的钱，也可能不是本期成本。\n归母净利润为什么会有归母净利润大部分上市公司都控制着数量不等的子公司，部分子公司上市公司持有其100% 股权，也有很多只是持有大部分股份的控股子公司。由于上市公司制作合并报表时，是将子公司的全部资产、负债、收入和费用统一计算的，这无形中将控股子公司合作伙伴的少部分股份所对应的资产、负债，以及损益也合并进来了。所以合并报表需要有个科目单独汇报这部分数据。在合并资产负债表里，该科目叫做“少数股东权益”，用于放置合作伙伴持有的少部分股权所对应的股东权益总和。在合并利润表里，汇总合作伙伴们持有子公司少数股份所对应的损益，叫作“少数股东损益”。\n\n\n\n\n少数股东权益\n少数股东损益\n\n\n\n出现表不同\n合并资产负债表\n合并利润表\n\n\n含义不同\n权益指净资产\n损益，指利润或亏损\n\n\n归母净利润如何计算归属于母公司所有者权益 &#x3D; 上市公司本部及其子公司的全部资产 - 全部负债 - 少数股东权益简称“归母净资产” 。\n归属于母公司所有者净利润 &#x3D; 合并利润表净利润 - 少数股东权益简称“归母净利润”或者“归母净利”\n市盈率（Price&#x2F;Book Value, PB） &#x3D; 股票价格 &#x2F; 每股净资产PB &#x3D; 公司总市值 &#x2F; 归母净资产\n市净率（Price&#x2F;Earning） &#x3D; 股票价格 &#x2F; 每股收益\n现金流量表\n现金量流表简单来说就是记流水账，类似年初有多少现金，期间收到多少，付出去多少，还剩多少。\n\n由于现金不产生任何收益，所以企业应尽最大可能减少持有现金的数量才是明智的。同时按照我国《现金管理暂行条例》，允许企业保留的现金限额，一版以三到五天的日常零星开支为限。边远地区和交通不便地区的企业，也不得超过十五天的日常零星开支。\n\n现金等价物：日常经营所需的流动资金，一般以银行存款、理财产品或高流动性的短期债券形式存在，这些东西都被称为“现金等价物”。\n现金流量表就是记录现金和现金等价物在本报告期内的变动情况。\n经营活动：\n\n企业销售商品；\n企业提供劳务带来的现金收入；\n以及对应的现金支出。\n\n要注意的是，对于不同类型的企业，其经营活动是不一样的。\n例如，对于制造企业来说，它的经营活动指的是生产或销售商品。企业借入&#x2F;借出资金，或者拿现金去买卖股票都不应该属于其经营活动。但对于银行来说，借入&#x2F;借出的资金恰恰是它的经营活动对于证券公司来说，利用公司资金买卖股票也是其企业经营活动的一部分。\n计入经营活动产生的现金流量。\n投资活动：\n\n包括企业的固定资产、无形资产等长期资产的买入或处置\n对外股权的投资和处置以及持有期间的理财投资\n\n对于该项需要注意的是，现金及现金等价物范围的理财类投资，如现金变成活期存款，或活期存款变成高流动性短期债券，不会被计算为投资活动现金流入或流出。（因为它只涉及到现金及现金等价物之间的转换，而非流入和流出）\n计入投资活动产生的现金流量。\n筹资活动：\n\n扩大或缩小股本规模\n对外举债或还债行为\n\n需要注意的是，该处的举债或还债行为，不包括企业日常经营活动中产生的应收应付款项。\n计入筹资活动产生的现金流量。\n对于涉及到境外资金的企业，还需要关注汇率变动对现金及现金等价物的影响表项。\n其它内容对于研读财报来说，除了关注以上三张表外，董事会报告和重要事项是必须细读的内容。\n董事会报告最好是将多年的连在一起读。通过前后对比，来判断董事会说话是否可信，对市场判断是否准确，对企业掌控力的强弱等等。\n附注对三张表有任何疑问，都需要在报表的附注部分去寻找解释。\n企业必须披露却又不太想让你明白的东西，一般都藏在附注里。从这个意义上来说，财报附注也是投资者必须阅读的内容。\n","tags":["读书笔记","投资理财","手把手教你读财报"]},{"title":"使用SSH转发连接远程localhost 端口","url":"/2022/01/09/5.%E4%BD%BF%E7%94%A8SSH%E8%BD%AC%E5%8F%91%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8Blocalhost-%E7%AB%AF%E5%8F%A3/","content":"前言目前博客使用的是Hexo 的框架进行部署的，所以在每次发布博客前，我都可以通过hexo server —-debug 来对新的页面进行检验，保证页面的整体格式、内容、图片都是得当的。使用hexo server会在服务器端的环回地址（localhost or 127.0.0.1）开启一个4000 端口的侦听进程，给管理员提供访问。\n我们可以通过iptalbes 等防火墙技术来配置SNAT 达到远程访问服务器环回地址的作用，但这样做有几个不妥之处：1. 我们需要将一个debug 的进程暴露给公网，且该进程是没有提供用户身份认证服务的； 2. hexo server 提供的是HTTP 的页面访问，并没有使用HTTPS 对相关流量进行加密。\n后来通过搜索文档，我找到了一个使用SSH 来将本地端口和远程服务器端口绑定的一种方法，在此分享给大家。\n\n\nSSH 的配置搜索SSH 的man page，可以看到对-L的注释如下：\n\nSpecifies that connections to the given TCP port or Unix socket on the local (client) host are to be forwarded to the given host and port, or Unix socket, on the remote side.  This works by allocating a socket to listen to either a TCP port on the local side, ptionally bound to the specified bind_address, or to a Unix socket.  Whenever a connection is made to the local port or socket, the connection is forwarded over the secure channel, and a connection is made to either host port hostport, or the Unix socket remote_socket, from the remote machine.指定要将与本地(客户端)主机上给定TCP端口或Unix套接字的连接转发到远程端的给定主机和端口或Unix套接字。这是通过分配套接字来侦听本地端的TCP端口(临时绑定到指定的BIND_ADDRESS或Unix套接字)来实现的。每当连接到本地端口或套接字时，都会通过安全通道转发连接，并从远程计算机建立到主机端口hostport或Unix套接字remote_socket的连接。\n\n# 用法-L [bind_address:]port:host:hostport-L [bind_address:]port:remote_socket-L local_socket:host:hostport-L local_socket:remote_socket# [bind_address:]port 通常是本地端口，例如 localhost:4000# host:hostport 是远端服务器地址和端口\n\n\n指定本地端口转发到服务器端4000 端口所以如果我希望在本地浏览hexo服务器的localhost:4000端口，我可以在terminal 使用如下命令：\n# 将发送到本地的4000 端口的流量转发到远程服务器149.28.131.106 的127.0.0.1:4000 ssh -L 4000:127.0.0.1:4000 root@149.28.131.106\n\n\n效果展示\n打开hexo 博客的server 模式hexo server --debug：# 得到提示04:49:51.611 INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.04:49:51.626 DEBUG Database saved\n在本地terminal （终端）中，输入ssh -L 4000:127.0.0.1:4000 root@149.28.131.106 \n使用浏览器打开localhost:4000页面，如果成功打开博客主页且服务器端debug 进程有连接请求，则配置成功  \n\n","tags":["建站","运维"]},{"title":"OS - 委托协议栈发送消息","url":"/2022/01/11/6.OS-%E5%A7%94%E6%89%98%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF/","content":"前言这个系列的博客是针对阅读《网络是怎样连接的》（[日] 户根勤, 译 [中] 周自恒, ISBN: 9787115441249）一书的记录与思路整理。有些概念是做纯路由交换的网络工程师很少接触但又很重要的部分，因此整理到这里以做分享。\n\n\n协议栈委托全貌应用程序做网络通讯需要委托操作系统协议栈来搭建数据通道并发送数据，这一过程需要按一定顺序调用socket 库中一系列的组件。\n收发数据的两台计算机之间连接了一条数据通道，数据沿着这条通道流动，最终到达目的地。我们可以把数据通道想象成一条管道，将数据从一端送入管道，数据就会到达管道的另一端然后被取出。数据可以从任何一端被送入管道，数据的流动是双向的。\n对于一个TCP 应用来说，可以总结成以下4个通讯过程：\n\n创建套接字\n将管道连接到服务器端的套接字上\n收发数据\n断开管道并删除套接字\n\n\n\n前面这 4 个操作都是由操作系统中的协议栈来执行的，浏览器等应用程序并不会自己去做连接管道、放入数据这些工作，而是委托协议栈来代劳。此外，这些委托的操作都是通过调用 Socket 库中的程序组件来执行的，但这些数据通信用的程序组件其实仅仅充当了一个桥梁的角色，并不执行任何实质性的操作，应用程序的委托内容最终会被原原本本地传递给协议栈。因此，我们无法形象地展示这些程序组件到底完成了怎样的工作，与其勉强强调 Socket 库的存在，还不如将 Socket 库和协议栈看成一个整体并讲解它们的整体行为让人更容易理解。\n\n创建套接字阶段\n客户端创建套接字的操作非常简单，只要调用Socket 库中的socket 程序组件就可以了。调用socket 之后，控制流程会转移到socket 内部并执行创建套接字的操作，完成后控制流程又会移交回应用程序。\n\n“书中出现了 Socket、socket、套接字（英文也是 socket）等看起来非常容易混淆的词，其中小写的 socket 表示程序组件的名称，大写字母开头的 Socket 表示库，而汉字的“套接字”则表示管道两端的接口。”\n\n套接字创建完成后，协议栈会返回一个描述符，应用程序会将收到的描述符放到内存中。描述符是用来识别不同的套接字的。\n\n计算机中会同时进行多个数据的通信操作，例如可以打开两个浏览器窗口，同时访问两台Web 服务器。这时，计算机内部有两个数据收发操作在同时进行，也就需要创建两个不同的套接字，进一步思考就必须有一种手段来识别不同的套接字，这个方法就是描述符。想象一下在酒店寄存行李的场景，酒店服务人员会分给你一个号码牌，向服务人员出示号码牌，就可以取回自己寄存的行李，描述符的远离和号码牌差不多。\n\n连接阶段应用程序通过调用Socket 库中的connect 程序，委托协议栈将客户端创建的套接字与服务器的套接字进行连接。\n调用connect 需要三个参数：\n\n描述符，在创建套接字时由协议栈返回的；协议栈通过描述符来判断应该对哪个套接字进行操作\n服务器IP 地址，在进行数据收发操作时，双方必须知道对方的IP 地址并告知协议栈。\n端口号，对端服务器套接字拥有的端口号。\n\n\n既然可以用创建套接字时，协议栈返还的描述符来标识每个套接字，那么访问远程服务器上的一个套接字为什么还需要用到端口呢？先说结论，不能用描述符来替代端口号。这是因为，描述符是和委托创建套接字的应用程序进行交互时使用的，另一方无法得知应用程序从协议栈获取了什么描述符（本地有效）。所以，我们需要另外一个对客户端也同样适用的机制，而这个机制就是端口号。\n\n端口号其实也是一个本地有效的编号，但是我们通过将常用服务的端口号实现规定好的方法来使之可以供客户端远程访问。例如HTTP 的端口号默认是80，HTTPS 的端口号默认是443。\n同样的，既然确定连接对象的套接字需要使用端口号，那么服务器也必须知道客户端套接字的端口号才行。客户端在创建套接字的时候，协议栈会为这个套接字随机分配一个端口号。接下来，当协议栈执行连接操作时，会将这个随机分配的端口号通知给服务器。\n\n描述符：应用程序用来识别套接字的机制；IP 地址和端口号：客户端和服务器之间用来识别对方套接字的机制。\n\n通信阶段 - 消息传递当套接字连接起来之后，剩下的事情就是将数据送入套接字。应用程序需要调用Socket 库中的write 程序来执行这个操作。\n数据发送首先应用程序需要在内存中准备好要发送的数据。在HTTP 的例子中，根据用户输入的网址生成的HTTP 请求消息就是我们要发送的数据。\n接下来应用程序调用write 时，需要制定描述符和发送数据，然后协议栈就会将数据通过指定的协议栈通道发送到服务器。由于套接字中已经保存了已连接的通信对象的相关信息，所以只要通过描述符指定套接字，就可以识别出通信对象，并向其发送数据了。\n接着，发送的数据会通过网络到达我们要访问的服务器。\n数据返回服务器执行接受操作，解析收到的数据内容并执行相应的操作，然后向客户端返回响应消息。\n接收消息的操作是应用程序通过Socket 库中的read 程序组件委派协议栈完成的。\n调用read 时需要指定用于存放接收消息的内存地址，这一内存地址被称之为缓冲区。于是，当服务器返回响应消息时，read 就会负责将接收到的响应消息存放到缓冲区中。而由于缓冲区是一块位于应用程序内部的内存空间，因此当消息被存放到缓冲区中时，就相当于数据已经转交给了应用程序。\n断开阶段当数据收发完毕，服务器和客户端会有一方主动发起断开。应用程序需要调用Socket 库中的close 程序来完成此操作。最终，连接在套接字之间的管道会断开，而客户端的套接字本身也会被删除。\n\n“断开的过程如下。Web 使用的 HTTP 协议规定，当 Web 服务器发送完响应消息之后，应该主动执行断开操作，因此 Web 服务器会首先调用 close 来断开连接。断开操作传达到客户端之后，客户端的套接字也会进入断开阶段。接下来，当浏览器调用 read 执行接收数据操作时，read 会告知浏览器收发数据操作已结束，连接已经断开。浏览器得知后，也会调用 close 进入断开阶段。” - HTTP 1.0\n\n\n“这就是 HTTP 的工作过程。HTTP 协议将 HTML 文档和图片都作为单独的对象来处理，每获取一次数据，就要执行一次连接、发送请求消息、接收响应消息、断开的过程。因此，如果一个网页中包含很多张图片，就必须重复进行很多次连接、收发数据、断开的操作。对于同一台服务器来说，重复连接和断开显然是效率很低的，因此后来人们又设计出了能够在一次连接中收发多个请求和响应的方法。在 HTTP 版本 1.1 中就可以使用这种方法，在这种情况下，当所有数据都请求完成后，浏览器会主动触发断开连接的操作。”\n\n","tags":["读书笔记","网络技术","网络是怎样连接的"]},{"title":"协议栈 - 创建套接字","url":"/2022/01/11/7.%E5%8D%8F%E8%AE%AE%E6%A0%88-%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97/","content":"前言这个系列的博客是针对阅读《网络是怎样连接的》（[日] 户根勤, 译 [中] 周自恒, ISBN: 9787115441249）一书的记录与思路整理。有些概念是做纯路由交换的网络工程师很少接触但又很重要的部分，因此整理到这里以做分享。\n\n\n协议栈的内部结构协议栈的工作我们从表面上是看不见的，可能比较难想象。因此，我们先来对协议栈做个解剖，看看里面到底有什么。\n\n协议栈的内部上图，分为几个部分，分别承担不同的功能。在这张图中，上面的部分会向下面的部分委派工作，下面的部分接收委派的工作并实际执行。\n对照上图我们从上到下捋一遍。\n最上面的部分是网络应用程序，例如：浏览器、电子邮件客户端、web 服务器、电子邮件服务器等，它们会将收发数据等工作委派给下层来完成。可以说，尽管不同的应用程序收发的数据内容不同，但收发数据的操作是共通的。\n应用程序下面是Socket 库，Socket 库中的应用程序，例如gethostbyname、socket、connect等开放给上层应用程序，可以由应用程序直接调用来获取相应的能力。\n再下面就是操作系统内部了，其中包括协议栈。协议栈的上半部分分为两块（OSI 模型的第四层），分别是负责用TCP 协议收发数据的部分和负责用UDP 协议收发数据的部分，它们会接受应用程序的委托执行收发数据的操作。（TCP 与UDP 的对比，不在此处赘述）\n再往下是用IP 协议控制网络包收发操作的部分。在互联网上传送数据时，数据会被切分成一个个的网络包（package），而将网络包发送给通信对象的操作就是由IP 来负责的。此外，IP中还包括ICMP协议（用于告知网络包传送过程中产生的相关错误以及各种控制信息）和ARP 协议（根据IP 地址查询相应的以太网MAC 地址）。\nIP 下面则是网卡驱动程序负责控制网卡硬件，最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收的操作。\n套接字的实体就是通信控制信息协议栈内部有一块用于存放控制信息的内存空间，包含IP、Port、Status、Protocol 等信息。我们可以说这些控制信息就是套接字的实体，或者说存放控制信息的内存空间就是套接字的实体。\n\n“这里的控制信息类似于我们在笔记本上记录的日程表和备忘录。我们可以根据笔记本上的日程表和备忘录来决定下一步应该做些什么，同样地，协议栈也是根据这些控制信息来决定下一步操作内容的。”\n\n示例协议栈在执行操作时需要参阅这些控制信息。\n\n在发送数据时，需要看一看套接字中的通信对象IP 地址和端口号，以便向指定的目标发送数据。\n发送数据后，协议栈需要等待对方返回收到数据的响应信息（TCP），数据在传输过程中是有可能丢失的，所以发送方不可能永远等下去，需要在一定时间之后重新发送未收到回应信息的数据，所以我们的套接字（控制信息）中必须要记录是否已经收到响应，以及发送数据后经过了多长时间。协议栈才能根据这些信息执行相应的重发操作。\n\n总结下来就是，套接字中记录了用于控制通信操作的各种控制信息，协议栈需要根据这些信息判断下一步的行动。\nUbuntu 中的套接字在Ubuntu 中，使用ss命令可以查看套接字的相关信息（还可以继续使用netstat命令）\n# 查看所有tcp 协议的套接字root@VM-20-3-ubuntu:~# ss -atnwNetid       State        Recv-Q        Send-Q               Local Address:Port                   Peer Address:Port       Processicmp6       UNCONN       0             0                           *%eth0:58                                *:*tcp         LISTEN       0             4096                       0.0.0.0:111                         0.0.0.0:*tcp         LISTEN       0             4096                 127.0.0.53%lo:53                          0.0.0.0:*tcp         LISTEN       0             128                        0.0.0.0:22                          0.0.0.0:*tcp         LISTEN       0             1024                       0.0.0.0:443                         0.0.0.0:*tcp         ESTAB        0             0                        10.0.20.3:48234                 169.254.0.138:8086tcp         ESTAB        0             0                        10.0.20.3:22                  163.125.203.219:4958tcp         ESTAB        0             0                        10.0.20.3:22                  163.125.203.219:6081tcp         ESTAB        0             36                       10.0.20.3:22                  163.125.203.219:5597tcp         ESTAB        0             0                        10.0.20.3:35592                  169.254.0.55:5574tcp         LISTEN       0             4096                          [::]:111                            [::]:*tcp         LISTEN       0             1024                          [::]:443                            [::]:*\n\n\n\n第一列为协议\n第二列为状态\n第三列和第四列为显示排队等待接收和发送的数据量\n第五列为本地IP地址和端口组（0.0.0.0 和[::] 代表尚未开始通信的套接字）\n第六列为对端IP 地址和端口组（0.0.0.0 和[::] 代表尚未开始通信的套接字）\n\n以第12行为例，一个进程在使用IP地址为10.0.20.3 的网卡与IP地址为163.125.203.219 的对象进行通信，对方使用了5597 端口，我方使用了22端口（是SSH 服务器的默认端口，因为这是在服务器上截取的socket 状态）。因此我们能看出来这个套接字是远端163.125.203.219 连接到本地10.0.20.3 的一个SSH 通道。\n调用socket 时的操作（创建套接字）当一个应用程序调用Socket 库中的socket、connect 等程序组建时，协议栈内部是如何工作的呢？\n\n应用程序调用socket 申请创建套接字，协议栈根据应用程序的申请执行创建套接字的操作：\n\n协议栈首先会分配用于存放一个套接字所需的内存空间给应用程序。即一个记录套接字控制信息的容器。\n在套接字的内存空间中写入本地初始状态的控制信息。完成该步骤套接字就算创建成功了。\n将表示这个套接字的描述符告知应用程序。描述符相当于用来区分协议栈中的多个套接字的号码牌。\n收到描述符后，应用程序再向协议栈进行收发数据委托时只需要提供这个描述符即可。因为套接字中记录了通信双方的信息和通信处于什么状态，所以只要通过描述符确定了相应的套接字，协议栈就能获取所有的相关信息，这样应用程序就不需要每次都告诉协议栈和谁去通信。\n\n其实很容易理解为何刚刚创建的套接字只有本端信息而没有对端信息。想想服务器上的网络程序，这些程序往往只能等待客户端的连接而无法主动连接客户端，如果设备创建的套接字中有对端的信息，那么很显然服务器会主动连接客户端，这与我们现在使用的C&#x2F;S 模型是完全不相符的。\n","tags":["读书笔记","网络技术","网络是怎样连接的"]},{"title":"协议栈 - 套接字连接","url":"/2022/01/11/8.%E5%8D%8F%E8%AE%AE%E6%A0%88-%E5%A5%97%E6%8E%A5%E5%AD%97%E8%BF%9E%E6%8E%A5/","content":"前言这个系列的博客是针对阅读《网络是怎样连接的》（[日] 户根勤, 译 [中] 周自恒, ISBN: 9787115441249）一书的记录与思路整理。有些概念是做纯路由交换的网络工程师很少接触但又很重要的部分，因此整理到这里以做分享。\n\n\n连接的本质是什么？以网页访问为例，我们知道，客户端和服务器刚创建的套接字中只包含了本端通信对象的信息，IP、端口、协议等等。客户端和服务器双方都无法在不知道对端信息的情况下通信，这就需要连接这个步骤来帮助客户端和服务器交换双方的信息。\n客户端：应用程序将服务器的IP地址、端口号等信息告诉协议栈，协议栈以此为目的去连接远程的服务器。\n服务器：等待客户端主动向自己告知客户端的IP地址、端口号等信息。\n所以连接实际上是通信双方交换控制信息，在套接字中记录通信所需的必要信息并准备数据收发的一连串操作。像上面提到的客户端将IP地址和端口号告知服务器这样的过程就属于交换控制信息的一个具体的示例。所谓的控制信息，就是用来控制数据收发操作所需要的一些信息，IP地址和端口号是典型的例子。除此之外，还有其它一些控制信息，我们暂且按下不表。\n同时连接要为数据收发作准备，我们还需要一块用来临时存放要收发的数据的内存空间，这块内存空间被称之为缓冲区，也会在连接阶段分配。\n\n“使用“连接”这个词是有原因的。通信技术的历史已经有 100 多年，从通信技术诞生之初到几年之前的很长一段时间内，电话技术一直都是主流。而电话的操作过程分为三个阶段：（1）拨号与对方连接；（2）通话；（3）挂断。人们将电话的思路套用在现在的计算机网络中了，所以也就自然而然地将通信开始之前的准备操作称为“连接”了。如果没有这段历史的话，说不定现在我们就不叫“连接”而是叫“准备”了。因此，如果觉得“连接”这个词听起来有些怪，那么用“准备”这个词来替换也问题不大。”\n\n负责保存控制信息的头部关于控制信息，其实大体上可以分为两类。\nC&#x2F;S 互相联络时的控制信息客户端和服务器互相联络时交换的控制信息。这类信息在通信的整个过程（连接、收发数据和断开连接）中都需要，这些内容表现在TCP 包头中。\n\n\n头部是用来记录和交换控制信息的。\n套接字中控制协议栈操作的信息应用程序传递来的信息和从通信对象接收到的信息都会保存到缓冲区。\n收发数据操作的执行状态等信息也会保存到缓冲区。\n协议栈会根据这些信息来执行每一步操作。可以说，套接字的控制信息和协议栈的程序本身就是一体的，因此“协议栈具体需要哪些信息”会根据协议栈本身的实现方式不同而不同。\n这一点对通信的双方来说是没有什么问题的。因为，协议栈中的控制信息通信对方是不可见的，只要在通信时按照规则将必要的信息写入头部，客户端和服务器之间的通信就能够成立（通信的过程遵循TCP 协议即可）。例如Windows 系统和Linux 系统的内部结构不同，协议栈的实现方式不同，必要的控制信息也不相同。但是，两个操作系统之间依然能够通信。\n\n“无论协议栈的实现如何不同，IP 地址和端口号这些重要的信息都是共通的。”\n\n连接操作的实际过程（TCP的三次握手）应用程序调用Socket 库的connect 程序组件就开始了连接的过程。\nconnect (&lt;描述符&gt;, &lt;服务器IP地址, 端口号&gt;,...)\n应用程序进行上面的调用就为协议栈的TCP模块提供了服务器的IP地址和端口号。TCP模块就会与该IP地址对应的TCP模块交换控制信息。\n\n客户端先创建一个包含表示开始数据收发操作的控制信息的头部。这里关注的重点是发送方和接收方的端口号。（在这一步客户端已经具备了准确找到服务器套接字的能力，搞清楚了我要连接哪个套接字。）\n将头部中的控制位SYN 比特设置为1，此外还需要设置适当的序号和窗口大小。\n当TCP头部创建成功，TCP模块会委托IP模块将信息发送出去。IP模块执行将数据包发送给服务器。\n服务器接收到数据包，服务器的IP模块会将收到的数据传递给TCP模块，TCP模块根据TCP头部的目的端口找到端口号对应的套接字。（从处于连接状态的套接字中找到与TCP头部中记录的端口号相同的套接字）\n服务器的TCP模块开始返回响应。需要在响应的TCP 头部中将接收到的源目端口对调，将SYN比特设置为1，同时还需要将ACK控制位设置为1。服务器TCP模块委托IP模块将信息发送出去。\n客户端IP模块接收到数据，将其传送给TCP模块。客户端的TCP模块通过头部信息确认连接服务器的操作是否成功。如果SYN设置为1表示连接成功，这时TCP模块会向套接字中写入服务器的IP地址、端口号等信息，同时还会将状态改为连接完毕。客户端此时还需要将头部信息的ACK比特设置为1发送回服务器，告诉服务器刚才的响应已经收到。\n当服务器收到这个返回包之后，连接操作算是全部完成。\n\n建立连接之后，协议栈的连接操作就结束了，也就是说connect已经执行完毕，控制流程被交回到应用程序。\n","tags":["读书笔记","网络技术","网络是怎样连接的"]},{"title":"协议栈 - 数据收发","url":"/2022/01/11/9.%E5%8D%8F%E8%AE%AE%E6%A0%88-%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91/","content":"前言这个系列的博客是针对阅读《网络是怎样连接的》（[日] 户根勤, 译 [中] 周自恒, ISBN: 9787115441249）一书的记录与思路整理。有些概念是做纯路由交换的网络工程师很少接触但又很重要的部分，因此整理到这里以做分享。\n\n\n协议栈 - 数据收发当控制流程从connect回到应用程序之后，接下来就进入数据的收发阶段了。数据收发操作是从应用程序调用write组件将要发送的数据交给协议栈开始的。\n数据类型无关性协议栈并不关心应用程序传递的数据是什么内容。应用程序调用write时指定发送数据的长度，在协议栈看来，要发送的数据就是一定长度的二进制字节序列而已。\n数据发送协议栈并非一收到数据就马上发送出去，而是将数据存放在内部的发送缓冲区中，等待一段时间再发送。这样做的理由是，应用程序交给协议栈发送的数据长度是由应用程序本身决定的，不同的应用程序在实现上不同，有些程序会一次性传递所有的数据，有些程序会逐字节或逐行传递数据。这是协议栈不能控制的行为，在这样的情况下，如果协议栈一收到来自应用程序的数据就立即发送，就可能会发送大量的小包，导致网络效率下降。因此积累到一定的数量再发送出去，是合理的。至于积累多少数据再发送，不同种类和版本的操作系统会有所不同，不能一概而论。\n积累数据的大小有以下两个因素来决定。\n\nMTU\nMTU 表示一个网络包的最大长度，在一般的以太网中，这个值一般设置为1500字节。MTU 是包含头部的总长度，因此需要从MTU减去头部长度，得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫做MSS。当应用长度收到的数据长度超过或接近MSS 时发送，可以避免发送大量小包的问题。\n\n\n时间\n当应用程序发送数据的频率不高的时候，如果每次都等待长度接近MSS时再发送，可能会因为等待时间太长而造成发送延迟，这种情况下即使缓冲区的数据长度没有达到MSS，也应该发送出去。为此，协议栈的内部有一个计时器，当经过一定时间后，就会将缓冲区数据打包送出。\n\n\n\n\n判断的因素只有两个，但它们其实是互相矛盾的。如果长度优先，那么网络的效率会提高，但可能会因为等待填满缓冲区而产生延迟；相反地，如果时间优先，那么延迟时间会变少，但又会降低网络的效率。因此，在进行发送操作时需要综合考虑这两个要素以达到平衡。不过，TCP 协议规格中并没有告诉我们怎样才能平衡，因此实际如何判断是由协议栈的开发者来决定的，也正是由于这个原因，不同种类和版本的操作系统在相关操作上也就存在差异。\n\n同时，协议栈给应用程序也保留了控制发送时机的余地。应用程序在发送数据时可以指定一些选项，例如指定“不等待填满缓冲区直接发送”，则协议栈会按照应用程序的要求来处理数据。\n对较大数据进行拆分当应用程序提交到发送缓冲区的数据很大，远远超过MSS的长度时，例如在博客或论坛上发表长文。\n这种情况下，发送缓冲区的数据远超MSS 的长度，协议栈无需等待后面的数据即可发送。发送缓冲区的数据会被以MSS长度为单位进行拆分，拆分出来的每块数据会被放进单独的网络包中。每一块数据的前面都会添加上TCP头部，并根据套接字中记录的控制信息标记发送方和接收方端口号，然后交给IP模块执行发送数据的操作。\n\n使用ACK 号确认网络包已收到\n序号的作用：用来标识每一个TCP 数据包相当于从头开始的第几个字节。还可以用来检验接收方收到的网络包有没有遗漏。假设，上次收到第1460字节，那么接下来如果收到的序号为1461的数据包，则表明传输过程没有遗漏；但如果收到的包序号为2921，那就说明中间有包遗漏了。\nACK 号的作用：如果接收方确认接收过程没有遗漏，接收方会将到目前为止接收到的数据长度加起来，计算出一共已收到多少个字节，这个数值就是ACK 号；也可以将ACK号理解为，下一个接收的数据包中期待的序号。\n\n“简单来说，发送方说的是“现在发送的是从第 ×× 字节开始的部分，一共有 ×× 字节哦！”而接收方则回复说，“到第 ×× 字节之前的数据我已经都收到了哦！”\n\n序号不是从0或1开始的一般来说为了讲解的方便，大家习惯描述一个TCP连接的序号是从0或1开始的（其实在wireshark 的抓包软件中，会针对TCP流将序号显示一个相对序列号，TCP 的首包seq 相对序列号为0）。但在实际通信过程中，序号是需要用随机数计算出一个初始值。这是因为如果序号都从0 或1开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。\n数据双向传输的序列号和ACK序号和ACK 是TCP 协议进行数据确认的思路，这种想法能够确认单向的数据传输。但是TCP 的数据收发是双向的，所以我们需要在连接时，分别同步客户端和服务器两端的序列号。这样在TCP两端收发的数据就能通过各自的序列号和ACK 值来进行确认了。\n\n根据网络包平均往返时间调整ACK号等待时机在TCP中采用了动态调整等待时间的方法，为什么？\n真实的网络环境千变万化，如果将ACK 号返回的等待时间设定为一个固定值，这显然无法满足很多时候网络的真实情况。例如，当网络繁忙以至于拥塞的时候，ACK号的返回会变慢。如果这时我们设置的等待值小了，发送方在等待超时后重传报文，ACK 号才姗姗来迟，那么重传就已经发生了。显而易见的，发送方刚刚完成的重传是多余的，而且看似只是多发出了一个包，但对本来已经拥塞的网络无疑是雪上加霜。同样的，将等待时间直接设为一个更大的值，也是不可取的，发送方等待时间过长，也就意味着发送缓冲区的数据无法及时清理，势必也增加了发送方的内存占用等情况。\n正因为真实的网络波动是无法预测的，所以将等待时间设置一个固定值并不是一个好办法。因此，TCP采用了动态调整等待时间的方法。简单来说，TCP会在发送数据的过程中持续测量ACK 号的返回时间，如果ACK号返回变慢，则相应延长等待时间；相对地，如果ACK号马上就能返回，则相应的缩短等待时间。\n\n“ 由于计算机的时间测量精度较低，ACK 返回时间过短时无法被正确测量，因此等待时间有一个最小值，这个值在每个操作系统上不一样，基本上是在 0.5 秒到 1 秒之间。”\n\n使用窗口管理ACK号为什么会有滑动窗口如果TCP的收发方都是在接收到对方返回ACK号之后再传递下一个数据，即没发送一个包就等待一个ACK号。那么在等待ACK号的这段时间，简直就是浪费资源和时间。为了减少这样的浪费，TCP 采用了这样的办法：发送一个包之后，无需等待ACK号返回，而是直接发送后续的一系列包。\n但是直接发送无脑发送数据在某些情况下也是有问题的。当接收方的TCP收到包后，会先将数据存放到接收缓冲区中。然后，接收方需要计算序号，将数据块组装还原成原数据并传递给应用程序。如果这些操作尚未完成下一个数据包就到了，那么接收方会将新到的数据暂存在缓冲区中。这里的问题就是，假设接收方处理数据的效率低于接收数据的速率，那么缓冲区的数据会越来越多，直至缓冲区填满溢出。这样即使后面有数据到达，接收方也只能丢弃数据。所以TCP 需要一个机制来保证接收方接收缓冲区不爆满，想做到这一点，首先，接收方需要告诉发送方自己最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制。这就是滑动窗口方式。\n\n书中所写是：“接收方收到TCP包后，将其存储到缓冲区中。然后，接收方需要计算ACK号，将数据块组装起来还原成原本的数据并传递给应用程序。”我个人浅薄的理解将数据块重组是依赖序号的，而非ACK号，所以在笔记中直接写的是计算序号，将数据块重新组装。\n\n滑动窗口具体工作原理\n以上图为例，接收方首先告知发送方自己的缓冲区大小为4380字节，发送方发送了3个1460字节数据的数据包。这时发送方通过计算得知接收方缓冲区空间已占满，所以发送方停止发送数据，等待接收方更新滑动窗口。当接收方发送消息确认收到以上三个数据包的同时告知发送方自己的缓冲区大小现在是2920字节。那么发送方再次开始发送数据，直到接收方的接收缓冲区占满，或者收到接收方新的缓冲区通知。（ACK 在下一节讨论，此处仅仅只关注窗口）\n接收方给发送方告知自己接收缓冲区的大小的字段在TCP包头中被称为窗口字段。\n同时，需要注意上图是一个示例，是故意体现一种接收方来不及处理收到的包，导致缓冲区被填满的情况。实际上，接收方在收到数据之后马上就会开始进行处理，如果接收方的性能高，处理速度比包到达速率还要快，缓冲区马上就会被清空，并通过窗口字段告知发送方。\n另一个需要注意的点是，图中只显示了一侧的数据收发操作，实际环境中，数据的收发、滑动窗口等是双向 进行的。\nACK与窗口的合并ACK号是接收方用来向发送方确认已收到发送方发来的数据包。\n窗口是接收方用来通知发送方自己接收缓冲区的大小。\n两者是相互独立的。那么再深入思考一下，什么时候接收方该更新ACK号和窗口值呢？\n当接收方收到数据时，如果确认获取的数据没有问题，就应该向发送方返回ACK号，因此我们可以认为收到数据之后马上应该进行这一操作。\n而对于窗口的更新呢？当收到数据刚刚进入接收缓冲区的时候，有必要每次都想发送方更新窗口大小吗？其实是没有必要的，因为发送方在每次发送数据时减掉已发送数据长度就可以自行计算接收方当前接收缓冲区（窗口）的剩余长度了。真正有必要更新窗口大小的时机是在接收方的应用程序已经取出收到的数据并通知协议栈清空已取数据的缓存时，这个操作是发送方无法感知到的，而且这个操作会导致缓冲区剩余容量的增加，因此需要接收方告知发送方。\n那么综上所述，没收到一个包，接收方就需要向发送方分别发送ACK号和窗口更新这两个独立的包。这样一来，接收方发给发送方的包就太多了，导致网络效率下降。\n因此，实际情况是，接收方在发送ACK号和窗口更新时，不会马上把包发出去，而是等待一段时间，在这个过程中很可能出现其它的通知操作，这样就可以将两种通知合并在一个包中发送了。\n","tags":["读书笔记","网络技术","网络是怎样连接的"]},{"title":"22.个人知识库介绍","url":"/2022/05/18/22-%E4%B8%AA%E4%BA%BA%E7%9F%A5%E8%AF%86%E5%BA%93%E4%BB%8B%E7%BB%8D/","content":"个人知识库介绍这个系列的博文，主要是来讲述搭建个人知识库的过程中使用的工具和相关的经验介绍。旨在为有同样需求的朋友提供一个思路。\nObsidian 介绍使用Obisidian 进行知识整理和工作项目汇总是最近两个月的事情了，选择它最主要的原因是数据本地化和丰富的插件提供各种功能。\n在使用Obsidian 之前，我在长期的学习生涯和几年的工作中使用过OneNote、Notion和Wolai。OneNote 是学生时代使用最多的笔记本，优势毋庸置疑，背靠微软，不担心哪天会删库跑路，对手写笔的支持是我用过笔记本中最好的（当时用的三星的Tab S 平板，非常流畅，十分方便），当然后面几个笔记本软件已不支持手写输入了。\nNotion 块结构笔记本，每个块都有自己ID 可以在其他笔记中引用，构建知识之间的关联，数据表功能很好用，支持各种形式的转化和搜索，其次他的多人合作也是一大亮点，工作中项目信息可以在一个page 中多人更新（免费版有人数限制）；缺点是数据完全在云端而且服务器在国外，回国之后访问慢，而且在21年末有断连无法使用的现象。最担心的是某天被墙了，数据可能找不回来了。\n因为Notion 访问的问题，22年初换到了Wolai 笔记本，从Notion 的数据迁移挺麻烦的。优点是访问快，模板库丰富，很符合国人的使用习惯。缺点和Notion 大同小异，数据在纯云端（我开通了会员使用过本地的飞行模式，会有几种功能无法使用），数据安全很要命，尤其是网传Wolai 的CEO（或者是老板）咋样咋样，我没有详细查看，但还是会觉得公司的一些项目数据放在上面会有问题。\n综上，最初切换Obsidian 的动力就是数据本地化。但在使用了2个月后，觉得Obsidian 笔记本非常符合我的使用需求（爱好折腾，有定制化需求，愿意花时间）。因此在这里推荐给大家。\n主要优势在于：\n\n数据本地化，没有任何泄密的问题，所以存放项目数据也没有问题；\n插件库丰富，可以说不安装插件的Obsidian 是没有灵魂的Obsidian（后续我会陆续分享各种插件的相关配置和我的使用场景）；\n多端同步自由，有收费、免费的方案，可以在多个平台（Win、Mac、Linux、iPhone）之间同步（Android 我没试过所以不宣传了～）；\n\n同样也有一些限制或者说不足：\n\n无法多人协同工作（除非你将整个数据库分享到一个公用空间）；\n需要折腾～原始的Obsidian 并不惊艳；另外各种插件也需要折腾，已经给好几个插件的作者在Github 上开过Ticket 了，想构建想要的工作空间不是一件简单的事情；\n\nObsidian 展示工作台主页通过主页中的双向链接访问各个分组，同时将工作和学习的任务放在重要紧急四象限中。再将日常的反思，格言警句放在首页，起到强化警示的作用。右边 calendar 插件也能在一定程度上帮助进行日程规划（不过我个人用Mac 的提醒事项和日历更多）。\nDataview 数据检索产品数据库，使用Dataview 插件，像使用数据库一样进行资料检索。上图就是我过滤资料库中思科所有业务口为1G 电口的设备。\n嵌入网页应用增强体验嵌入微信读书，在Obsidian 中一边阅读一边梳理思路和笔记。随时可以进行摘抄（复制粘贴），不用来回切换窗口，体验感更加。\n还有更多的使用场景和技巧之后再分期讨论，感兴趣的欢迎交流。\n","tags":["Obsidian"]},{"title":"23.7130 配置总结","url":"/2022/05/19/23-7130-%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93/","content":"通用配置Hostname 配置Switch&gt;enableSwitch#configure terminalSwitch(config)#RTA\n\n管理口配置RTA(config)#interface Management 1RTA(config-Mgmt)#ip address x.x.x.x/xRTA(config)#ip routingRTA(config)#ip route default via x.x.x.xRTA(config)#management sshRTA(config-mgmt-ssh)#no shutdown\n\n升级OS\n安装Applicationhostname(config)# copy usb:metawathc-xx.xx.rpm file:metawatch-xx.xx.rpmhostname(config)# install app file:metawatch-xx.xx.rpm\n\nCross Point 配置-低延时直通配置点对点 cross point - 1:1\nhostname(config)&gt; int et2hostname(config-if-et2)&gt; source et1hostname(config-if-et2)&gt; no shuthostname(config)&gt; int et1hostname(config-if-et1)&gt; source et2hostname(config-if-et1)&gt; no shut\n\n配置点多多点cross point - 1:N\n\n首先需要配置一个1:1 模式（否则光口无法UP）hostname(config)&gt; int et2hostname(config-if-et2)&gt; source mac\n先配置et1 和et2 的1:1hostname(config)&gt; int et2hostname(config-if-et2)&gt; source et1hostname(config-if-et2)&gt; no shuthostname(config)&gt; int et1hostname(config-if-et1)&gt; source et2hostname(config-if-et2)&gt; no shut\n将et1 的流量同步复制到端口3hostname(config)&gt; int et3hostname(config-if-et3)&gt; source et1hostname(config-if-et3)&gt; no shut\n\nMetawatch 配置(多对一)// 关闭FPGA 上运行的程序，例如MetaMuxapp Metamux    shutdown// 安装 metawatch，先用命令app metawatch 验证交换机是否安装好了metawatchenableconfigcopy usb:metawathc-xx.xx.rpm file:metawatch-xx.xx.rpm// 如果u 盘无法识别， 通过管理口访问交换机的http管理页面上传rpm 包install app file:Metawatch-xx.xx.rpm\n\n// 启用metawatchapp Metawatch    shutdown    timesource freerun    mode 1x16_w    interface ap1-32 sub-nanoseconds    no shutdown\n\n// 配置源端口int Ap1    source Et41int Ap2    source Eth34int Ap3    source Eth1Int Eth41  Source macInt Eth34  Source macInt Eth1  Source mac\n\n// 配置目的端口int Et43    description toserver    source Ap31\n\n\n[!note]遇到新的设备，若不了解MetaWatch 可用的模式，可以在app metawatch 下使用命令list mode查看所有可用模式;\n若不熟悉模式下所有ap 接口的group，可以在启用mode 之后使用命令show int ap* description\n\nlist mode\nshow int ap* description\n","tags":["网络","Arista"]},{"title":"23.自动化办公系列-发货单处理","url":"/2022/05/23/23-%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E7%B3%BB%E5%88%97-%E5%8F%91%E8%B4%A7%E5%8D%95%E5%A4%84%E7%90%86/","content":"源文件\n\n\n序号\n订单号\n需求单号\n送货机房\n送货地址\n物料编号\n物料描述\n品名\n品牌\n型号\n期望货期\n实际到货日期\n固资号\nSN码\n箱号\n数量\n送货单数量\n待送货数量\n\n\n\n100179884521816131\nTSPO202201100059\nNPA202112100034\n敏感信息处理\n敏感信息处理\n795250EBKF2480\n敏感信息处理\n网络设备板卡\n敏感信息处理\n敏感信息处理\n2022&#x2F;7&#x2F;15\n\nTYNM220105829\nFOC2613NF1B\n20220513003\n1\n1\n1\n\n\n100179884521816130\nTSPO202201100059\nNPA202112100034\n敏感信息处理\n敏感信息处理\n795250EBKF2480\n敏感信息处理\n网络设备板卡\n敏感信息处理\n敏感信息处理\n2022&#x2F;7&#x2F;15\n\nTYNM220105828\nFOC2613NEZ5\n20220513004\n1\n2\n1\n\n\n100179884521816129\nTSPO202201100059\nNPA202112100034\n敏感信息处理\n敏感信息处理\n795250EBKF2480\n敏感信息处理\n网络设备板卡\n敏感信息处理\n敏感信息处理\n2022&#x2F;7&#x2F;15\n\nTYNM220105827\nFOC2613NF17\n20220513005\n1\n3\n1\n\n\n100179884521816128\nTSPO202201100059\nNPA202112100034\n敏感信息处理\n敏感信息处理\n795250EBKF2480\n敏感信息处理\n网络设备板卡\n敏感信息处理\n敏感信息处理\n2022&#x2F;7&#x2F;15\n\nTYNM220105826\nFOC2614K5UV\n20220513006\n1\n4\n1\n\n\n目标文件\n代码import qrcodefrom barcode import Code128from barcode.writer import ImageWriterimport pandas as pdimport jsonfrom PIL import Image as ImagePILimport osfrom openpyxl import Workbookfrom openpyxl.drawing.image import Image as ImageXLdef qrCodeGen(fName, info):    # info 是SN 码    # 之后会将文件名改成另一个形式，将所有信息进行统一    img = qrcode.make(info)    img.save(f&quot;&#123;fName&#125;&quot;)def barCodeGen(fName, info):    # info 是箱号    # 之后会讲文件名    # image pixel: 324 x 280    img = Code128(info, writer=ImageWriter())    img.save(f&quot;&#123;fName&#125;&quot;)def imgResize(fName, image):    # 图片缩减    # 打开原始图片，修改文件高度    img = ImagePIL.open(image)    img = img.resize((250, 130), ImagePIL.LANCZOS)    img.save(f&#x27;&#123;fName&#125;&#x27;)def imgCropper(fName, image):\t# 剪裁    img = ImagePIL.open(image)    cropped = img.crop((30,30,260,260))    cropped.save(fName)def excelProcesser(fName):    df = pd.read_excel(fName)    origin = df.to_json()    origin = json.loads(origin)    data = []    for key in origin[&quot;序号&quot;]:        # 按每个条目的序号、箱号、数量和SN 码生成一个新的列表        data.append([origin[&quot;序号&quot;][key], str(origin[&quot;箱号&quot;][key]), str(origin[&quot;数量&quot;][key]), origin[&quot;SN码&quot;][key], origin[&quot;订单号&quot;][key]])    return datadef regularWriter(worksheet, columeA, columeB, line, index):    worksheet[f&quot;&#123;columeA&#125;&#123;line&#125;&quot;] = &quot;PO NO.:&quot;    worksheet[f&quot;&#123;columeB&#125;&#123;line&#125;&quot;] = data[index][4]    worksheet[f&quot;&#123;columeA&#125;&#123;line+2&#125;&quot;] = &quot;BOX ID:&quot;    worksheet[f&quot;&#123;columeB&#125;&#123;line+2&#125;&quot;] = data[index][1]    worksheet[f&quot;&#123;columeA&#125;&#123;line+10&#125;&quot;] = f&quot;QTY: &#123;data[index][2]&#125; PCS&quot;    worksheet[f&quot;&#123;columeA&#125;&#123;line+12&#125;&quot;] = &quot;SN:&quot;    def pixelWriter(worksheet, columeA, line, index):        # 添加箱号Code 128    img = ImageXL(f&quot;&#123;data[index][0]&#125;/Box.png&quot;)    worksheet.add_image(img, f&quot;&#123;columeA&#125;&#123;line+3&#125;&quot;)    # 添加SN QRCode    img = ImageXL(f&quot;&#123;data[index][0]&#125;/SN.png&quot;)    worksheet.add_image(img, f&quot;&#123;columeA&#125;&#123;line+12&#125;&quot;)if __name__ == &quot;__main__&quot;:    pass    data = excelProcesser(&quot;1.xlsx&quot;)    for item in data:        os.mkdir(f&quot;&#123;item[0]&#125;&quot;)        qrCodeGen(f&quot;&#123;item[0]&#125;/SN.png&quot;, item[3])        barCodeGen(f&quot;&#123;item[0]&#125;/Box&quot;, item[1])        imgResize(f&quot;&#123;item[0]&#125;/Box.png&quot;, f&quot;&#123;item[0]&#125;/Box.png&quot;)        imgCropper(f&quot;&#123;item[0]&#125;/SN.png&quot;, f&quot;&#123;item[0]&#125;/SN.png&quot;)    wb = Workbook()    ws = wb.active    ws.title = data[0][4]    line = 1    for index in range(len(data)):        if index % 2 == 0:            # 添加订单文字信息            regularWriter(ws, &quot;C&quot;, &quot;D&quot;, line, index)            # 添加箱号Code 128&amp;QRCode            pixelWriter(ws, &quot;D&quot;, line, index)        else:            # 添加订单文字信息            regularWriter(ws, &quot;J&quot;, &quot;K&quot;, line, index)            # 添加箱号Code 128&amp;QRCode            pixelWriter(ws, &quot;K&quot;, line, index)            line += 26    wb.save(&quot;2.xlsx&quot;)\n\n生成QRCode 并将QRCode 裁剪掉白边import qrcodefrom PIL import Image as ImagePILdef qrCodeGen(fName, info):    # info 是SN 码    # 之后会将文件名改成另一个形式，将所有信息进行统一    img = qrcode.make(info)    img.save(f&quot;&#123;fName&#125;&quot;)def imgCropper(fName, image):\t# 剪裁    img = ImagePIL.open(image)    cropped = img.crop((30,30,260,260))    cropped.save(fName)\n\n生成BarCode 并将Barcode 缩减from barcode import Code128from barcode.writer import ImageWriterfrom PIL import Image as ImagePILdef barCodeGen(fName, info):    # info 是箱号    # 之后会讲文件名    # image pixel: 324 x 280    img = Code128(info, writer=ImageWriter())    img.save(f&quot;&#123;fName&#125;&quot;)def imgResize(fName, image):    # 图片缩减    # 打开原始图片，修改文件高度    img = ImagePIL.open(image)    img = img.resize((250, 130), ImagePIL.LANCZOS)    img.save(f&#x27;&#123;fName&#125;&#x27;)\n\n处理原始表格抓取有用数据在目标文件中，我们实际所需的数据有“订单号”，“SN码”，“箱号“和”数量“。但为了区分通过SN 生成的二维码和箱号生成的条形码，我们还需要”序号“来创建不同的目录存放对应的数据。所以最终构成了一个二维列表。[[“序号”, “箱号”, “数量”, “SN码”, “订单号”], [“序号”, “箱号”, “数量”, “SN码”, “订单号”]]\nimport pandas as pdimport jsondef excelProcesser(fName):\t# 通过pandas 读取excel 文件    df = pd.read_excel(fName)    # 转化成json 字符串    origin = df.to_json()    # 加载Json 字符串，形成一个字典数据    origin = json.loads(origin)    data = []    for key in origin[&quot;序号&quot;]:        # 按每个条目的序号、箱号、数量、SN 码和订单号生成一个新的列表        data.append([origin[&quot;序号&quot;][key], str(origin[&quot;箱号&quot;][key]), str(origin[&quot;数量&quot;][key]), origin[&quot;SN码&quot;][key], origin[&quot;订单号&quot;][key]])    return data\n\n工作流程\n处理原始表格获取需求数据\n通过“序号”值，生成对应的目录\n生成二维码和条形码到对应“序号”目录，通过PIL 调整生成的图像大小或剪裁\n生成一个新的Excel 表格\n根据订单号修改sheetname\n通过标准化输入，依次写入需要值和图像\n最后保存为”2.xlsx”\n\n","tags":["python","自动化办公"]}]